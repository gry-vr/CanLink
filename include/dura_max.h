/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 40.0.0 Tue Dec 17 14:15:45 2024.
 */

#ifndef DURA_MAX_H
#define DURA_MAX_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_FRAME_ID (0x18fdd500u)
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_FRAME_ID (0x10fcfd00u)
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_FRAME_ID (0x10fce300u)
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_FRAME_ID (0x18fe6900u)
#define DURA_MAX_DM21_DIAGNOSTIC_READINESS_2_FRAME_ID (0x18c1ff00u)
#define DURA_MAX_DM26_DIAGNOSTIC_READINESS_3_FRAME_ID (0x18fdb800u)
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_FRAME_ID (0x18fef600u)
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_FRAME_ID (0x18fef500u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_FRAME_ID (0xcf00400u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_FRAME_ID (0xcf00300u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_FRAME_ID (0x18fedf00u)
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_FRAME_ID (0x18feef00u)
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_FRAME_ID (0x18fedb00u)
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_FRAME_ID (0x18feee00u)
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_FRAME_ID (0x18fef200u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_FRAME_ID (0x18ecff00u)
#define DURA_MAX_TRANSPORT_PROTOCOL_DATA_FRAME_ID (0x18ebff00u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FRAME_ID (0x18feca00u)
#define DURA_MAX_TSC1_31_FRAME_ID (0xc000031u)
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_FRAME_ID (0x18fcf600u)
#define DURA_MAX_HOURS_ENGINE_HOURS_REVOLUTIONS_FRAME_ID (0x18fee500u)
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_FRAME_ID (0x18fe9700u)
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_FRAME_ID (0x18fef700u)
#define DURA_MAX_EEC20_ELECTRONIC_ENGINE_CONTROL__FRAME_ID (0x18fc0b00u)
#define DURA_MAX_EASI_ENGINE_AIR_SYSTEM_INFO_FRAME_ID (0xcf03900u)
#define DURA_MAX_TSC1_03_FRAME_ID (0xc000003u)
#define DURA_MAX_TSC1_0_B_FRAME_ID (0xc00000bu)
#define DURA_MAX_DM07_FRAME_ID (0x18e3005eu)
#define DURA_MAX_DM08_FRAME_ID (0x18fed000u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_FRAME_ID (0x18f00029u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_FRAME_ID (0xcf00203u)
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_FRAME_ID (0x18f00503u)
#define DURA_MAX_RQST_00_5_E_FRAME_ID (0x18ea005eu)
#define DURA_MAX_RQST_00_21_FRAME_ID (0x18ea0021u)
#define DURA_MAX_RQST_GLOBAL_5_E_FRAME_ID (0x18eaff5eu)
#define DURA_MAX_RQST_GLOBAL_03_FRAME_ID (0x18eaff03u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_FRAME_ID (0x18fd8321u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_FRAME_ID (0x18fef803u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_FRAME_ID (0x18feed00u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_FRAME_ID (0x18fef100u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_FRAME_ID (0x18f0010bu)
#define DURA_MAX_SHUTDN_FRAME_ID (0x18fee400u)

/* Frame lengths in bytes. */
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_LENGTH (8u)
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_LENGTH (8u)
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_LENGTH (8u)
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_LENGTH (8u)
#define DURA_MAX_DM21_DIAGNOSTIC_READINESS_2_LENGTH (8u)
#define DURA_MAX_DM26_DIAGNOSTIC_READINESS_3_LENGTH (8u)
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_LENGTH (8u)
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_LENGTH (8u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_LENGTH (8u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_LENGTH (8u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_LENGTH (8u)
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_LENGTH (8u)
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_LENGTH (8u)
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_LENGTH (8u)
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_LENGTH (8u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_LENGTH (8u)
#define DURA_MAX_TRANSPORT_PROTOCOL_DATA_LENGTH (8u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_LENGTH (8u)
#define DURA_MAX_TSC1_31_LENGTH (8u)
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_LENGTH (8u)
#define DURA_MAX_HOURS_ENGINE_HOURS_REVOLUTIONS_LENGTH (8u)
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_LENGTH (8u)
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_LENGTH (8u)
#define DURA_MAX_EEC20_ELECTRONIC_ENGINE_CONTROL__LENGTH (8u)
#define DURA_MAX_EASI_ENGINE_AIR_SYSTEM_INFO_LENGTH (8u)
#define DURA_MAX_TSC1_03_LENGTH (8u)
#define DURA_MAX_TSC1_0_B_LENGTH (8u)
#define DURA_MAX_DM07_LENGTH (8u)
#define DURA_MAX_DM08_LENGTH (8u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_LENGTH (8u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_LENGTH (8u)
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_LENGTH (8u)
#define DURA_MAX_RQST_00_5_E_LENGTH (3u)
#define DURA_MAX_RQST_00_21_LENGTH (3u)
#define DURA_MAX_RQST_GLOBAL_5_E_LENGTH (3u)
#define DURA_MAX_RQST_GLOBAL_03_LENGTH (3u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_LENGTH (8u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_LENGTH (8u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_LENGTH (8u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_LENGTH (8u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_LENGTH (8u)
#define DURA_MAX_SHUTDN_LENGTH (8u)

/* Extended or standard frame types. */
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_IS_EXTENDED (1)
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_IS_EXTENDED (1)
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_IS_EXTENDED (1)
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_IS_EXTENDED (1)
#define DURA_MAX_DM21_DIAGNOSTIC_READINESS_2_IS_EXTENDED (1)
#define DURA_MAX_DM26_DIAGNOSTIC_READINESS_3_IS_EXTENDED (1)
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_IS_EXTENDED (1)
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_IS_EXTENDED (1)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_IS_EXTENDED (1)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_IS_EXTENDED (1)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_IS_EXTENDED (1)
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_IS_EXTENDED (1)
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_IS_EXTENDED (1)
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_IS_EXTENDED (1)
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_IS_EXTENDED (1)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_IS_EXTENDED (1)
#define DURA_MAX_TRANSPORT_PROTOCOL_DATA_IS_EXTENDED (1)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_IS_EXTENDED (1)
#define DURA_MAX_TSC1_31_IS_EXTENDED (1)
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_IS_EXTENDED (1)
#define DURA_MAX_HOURS_ENGINE_HOURS_REVOLUTIONS_IS_EXTENDED (1)
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_IS_EXTENDED (1)
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_IS_EXTENDED (1)
#define DURA_MAX_EEC20_ELECTRONIC_ENGINE_CONTROL__IS_EXTENDED (1)
#define DURA_MAX_EASI_ENGINE_AIR_SYSTEM_INFO_IS_EXTENDED (1)
#define DURA_MAX_TSC1_03_IS_EXTENDED (1)
#define DURA_MAX_TSC1_0_B_IS_EXTENDED (1)
#define DURA_MAX_DM07_IS_EXTENDED (1)
#define DURA_MAX_DM08_IS_EXTENDED (1)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_IS_EXTENDED (1)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_IS_EXTENDED (1)
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_IS_EXTENDED (1)
#define DURA_MAX_RQST_00_5_E_IS_EXTENDED (1)
#define DURA_MAX_RQST_00_21_IS_EXTENDED (1)
#define DURA_MAX_RQST_GLOBAL_5_E_IS_EXTENDED (1)
#define DURA_MAX_RQST_GLOBAL_03_IS_EXTENDED (1)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_IS_EXTENDED (1)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_IS_EXTENDED (1)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_IS_EXTENDED (1)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_IS_EXTENDED (1)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_IS_EXTENDED (1)
#define DURA_MAX_SHUTDN_IS_EXTENDED (1)

/* Frame cycle times in milliseconds. */
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_CYCLE_TIME_MS (250u)
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_CYCLE_TIME_MS (100u)
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_CYCLE_TIME_MS (100u)
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_CYCLE_TIME_MS (1000u)
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_CYCLE_TIME_MS (500u)
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_CYCLE_TIME_MS (1000u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_CYCLE_TIME_MS (50u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_CYCLE_TIME_MS (50u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_CYCLE_TIME_MS (250u)
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_CYCLE_TIME_MS (500u)
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_CYCLE_TIME_MS (500u)
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_CYCLE_TIME_MS (1000u)
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_CYCLE_TIME_MS (100u)
#define DURA_MAX_TSC1_31_CYCLE_TIME_MS (10u)
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_CYCLE_TIME_MS (1000u)
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_CYCLE_TIME_MS (1000u)
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_CYCLE_TIME_MS (1000u)
#define DURA_MAX_EEC20_ELECTRONIC_ENGINE_CONTROL__CYCLE_TIME_MS (250u)
#define DURA_MAX_EASI_ENGINE_AIR_SYSTEM_INFO_CYCLE_TIME_MS (20u)
#define DURA_MAX_TSC1_03_CYCLE_TIME_MS (10u)
#define DURA_MAX_TSC1_0_B_CYCLE_TIME_MS (10u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_CYCLE_TIME_MS (100u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_CYCLE_TIME_MS (10u)
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_CYCLE_TIME_MS (100u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_CYCLE_TIME_MS (1000u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_CYCLE_TIME_MS (1000u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CYCLE_TIME_MS (100u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_CYCLE_TIME_MS (100u)
#define DURA_MAX_SHUTDN_CYCLE_TIME_MS (1000u)

/* Signal choices. */
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_FUEL_CONTROL_CONTROL_MODE_OPEN__LOOP_CHOICE (0u)
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_FUEL_CONTROL_CONTROL_MODE_CLOSED__LOOP_CHOICE (1u)
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_FUEL_CONTROL_CONTROL_MODE_SAE__RESERVED_CHOICE (2u)
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_FUEL_CONTROL_CONTROL_MODE_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_VGT_CONTROL_MODE_OPEN__LOOP_CHOICE (0u)
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_VGT_CONTROL_MODE_CLOSED__LOOP_CHOICE (1u)
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_VGT_CONTROL_MODE_SAE__RESERVED_CHOICE (2u)
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_VGT_CONTROL_MODE_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ACTL_ENG_PRCNT_TORQUE_HIGH_RESOLUTION__0_000__CHOICE (0u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ACTL_ENG_PRCNT_TORQUE_HIGH_RESOLUTION__0_125__CHOICE (1u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ACTL_ENG_PRCNT_TORQUE_HIGH_RESOLUTION__0_875__CHOICE (7u)

#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_START_NOT_REQUESTED_CHOICE (0u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_ACTIVE_BUT_NOT_ENGAGED_CHOICE (1u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_ACTIVE_AND_ENGAGED_CHOICE (2u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_START_FINISHED_CHOICE (3u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_ENGINE_ALREADY_RUNNING_CHOICE (4u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_ENGINE_NOT_READY_FOR_START_CHOICE (5u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_DRIVELINE_ENGAGED_OR_OTHER_TRANSMISSION_INHIBIT_CHOICE (6u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_ACTIVE_IMMOBILIZER_CHOICE (7u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_STARTER_OVER_TEMP_CHOICE (8u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_INTAKE_AIR_SHUTOFF_VALVE_BEING_ACTIVE_CHOICE (9u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_ACTIVE_EMISSIONS_CONTROL_SYSTEM_CONDITION_CHOICE (10u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_DUE_TO_IGNITION_KEY_CYCLE_REQUIRED_CHOICE (11u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_STARTER_INHIBITED_CHOICE (12u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_ERROR__LEGACY_IMPLEMENTATION_ONLY_CHOICE (13u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_ERROR_CHOICE (14u)
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_NOT_AVAILABLE_CHOICE (15u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL1_LOW_IDLE_SWITCH_ACCELERATOR_PEDAL_1_NOT_IN_LOW_IDLE_CONDITION_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL1_LOW_IDLE_SWITCH_ACCELERATOR_PEDAL_1_IN_LOW_IDLE_CONDITION_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL1_LOW_IDLE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL1_LOW_IDLE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL_KICKDOWN_SWITCH_KICKDOWN_PASSIVE_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL_KICKDOWN_SWITCH_KICKDOWN_ACTIVE_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL_KICKDOWN_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL_KICKDOWN_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ROAD_SPEED_LIMIT_STATUS_ACTIVE_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ROAD_SPEED_LIMIT_STATUS_NOT__ACTIVE_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ROAD_SPEED_LIMIT_STATUS_ERROR_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ROAD_SPEED_LIMIT_STATUS_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL2_LOW_IDLE_SWITCH_ACCELERATOR_PEDAL_2_NOT_IN_LOW_IDLE_CONDITION_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL2_LOW_IDLE_SWITCH_ACCELERATOR_PEDAL_2_IN_LOW_IDLE_CONDITION_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL2_LOW_IDLE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL2_LOW_IDLE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_VHCLE_ACCELERATION_RATE_LIMIT_STATUS_LIMIT_NOT_ACTIVE_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_VHCLE_ACCELERATION_RATE_LIMIT_STATUS_LIMIT_ACTIVE_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_VHCLE_ACCELERATION_RATE_LIMIT_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_VHCLE_ACCELERATION_RATE_LIMIT_STATUS_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_MMNTARY_ENG_MAX_POWER_ENABLE_FEEDBACK_DISABLED_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_MMNTARY_ENG_MAX_POWER_ENABLE_FEEDBACK_SUPPORTED_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_MMNTARY_ENG_MAX_POWER_ENABLE_FEEDBACK_RESERVED_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_MMNTARY_ENG_MAX_POWER_ENABLE_FEEDBACK_DON_T_CARE_CHOICE (3u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_DPF_THERMAL_MANAGEMENT_ACTIVE_DPF__THERMAL__MANAGEMENT_IS_NOT_ACTIVE_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_DPF_THERMAL_MANAGEMENT_ACTIVE_DPF__THERMAL__MANAGEMENT_IS_ACTIVE_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_DPF_THERMAL_MANAGEMENT_ACTIVE_RESERVED_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_DPF_THERMAL_MANAGEMENT_ACTIVE_DON_T_CARE_CHOICE (3u)

#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_SCR_THERMAL_MANAGEMENT_ACTIVE_SCR__THERMAL__MANAGEMENT_IS_NOT_ACTIVE_CHOICE (0u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_SCR_THERMAL_MANAGEMENT_ACTIVE_SCR__THERMAL__MANAGEMENT_IS_ACTIVE_CHOICE (1u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_SCR_THERMAL_MANAGEMENT_ACTIVE_RESERVED_CHOICE (2u)
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_SCR_THERMAL_MANAGEMENT_ACTIVE_DON_T_CARE_CHOICE (3u)

#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_IN_DEW_POINT_NOT_EXCEEDED_THE_DEW_POINT_CHOICE (0u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_IN_DEW_POINT_EXCEEDED_THE_DEW_POINT_CHOICE (1u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_IN_DEW_POINT_ERROR_CHOICE (2u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_IN_DEW_POINT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_EXH_DEW_POINT_NOT_EXCEEDED_THE_DEW_POINT_CHOICE (0u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_EXH_DEW_POINT_EXCEEDED_THE_DEW_POINT_CHOICE (1u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_EXH_DEW_POINT_ERROR_CHOICE (2u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_EXH_DEW_POINT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_IN_DEW_POINT_NOT_EXCEEDED_THE_DEW_POINT_CHOICE (0u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_IN_DEW_POINT_EXCEEDED_THE_DEW_POINT_CHOICE (1u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_IN_DEW_POINT_ERROR_CHOICE (2u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_IN_DEW_POINT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_EXH_DEW_POINT_NOT_EXCEEDED_THE_DEW_POINT_CHOICE (0u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_EXH_DEW_POINT_EXCEEDED_THE_DEW_POINT_CHOICE (1u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_EXH_DEW_POINT_ERROR_CHOICE (2u)
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_EXH_DEW_POINT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONTROL_BYTE_RTS_CHOICE (16u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONTROL_BYTE_CTS_CHOICE (17u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONTROL_BYTE_EO_MA_CHOICE (19u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONTROL_BYTE_BAM_CHOICE (32u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONTROL_BYTE_ABORT_CHOICE (255u)

#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_ALREADY_IN_ONE_OR_MORE_CONNECTION_MANAGED_SESSIONS_AND_CANNOT_SUPPORT_ANOTHER__CHOICE (1u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_SYSTEM_RESOURCES_WERE_NEEDED_FOR_ANOTHER_TASK_SO_THIS_CONNECTION_MANAGED_SESSION_WAS_TERMINATED__CHOICE (2u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_A_TIMEOUT_OCCURRED_AND_THIS_IS_THE_CONNECTION_ABORT_TO_CLOSE_THE_SESSION__CHOICE (3u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_CTS_MESSAGES_RECEIVED_WHEN_DATA_TRANSFER_IS_IN_PROGRESS__CHOICE (4u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_MAXIMUM_RETRANSMIT_REQUEST_LIMIT_REACHED_CHOICE (5u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_UNEXPECTED_DATA_TRANSFER_PACKET_CHOICE (6u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_BAD_SEQUENCE_NUMBER__SOFTWARE_CANNOT_RECOVER__CHOICE (7u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_DUPLICATE_SEQUENCE_NUMBER__SOFTWARE_CANNOT_RECOVER__CHOICE (8u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_TOTAL__MESSAGE__SIZE_IS_GREATER_THAN_1785_BYTES_CHOICE (9u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_CONNECTION__ABORT_REASON_IS_NOT_LISTED_CHOICE (250u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_ERROR_INDICATOR_CHOICE (254u)
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_NOT_AVAILABLE_CHOICE (255u)

#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_PG_NUMBER_NOT_AVAILABLE_CHOICE (255u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_PROTECT_LAMP_STATUS_LAMP__OFF_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_PROTECT_LAMP_STATUS_LAMP__ON_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_PROTECT_LAMP_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_PROTECT_LAMP_STATUS_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_AMBER_WARNING_LAMP_STATUS_LAMP__OFF_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_AMBER_WARNING_LAMP_STATUS_LAMP__ON_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_AMBER_WARNING_LAMP_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_AMBER_WARNING_LAMP_STATUS_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_RED_STOP_LAMP_STATE_LAMP__OFF_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_RED_STOP_LAMP_STATE_LAMP__ON_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_RED_STOP_LAMP_STATE_RESERVED_CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_RED_STOP_LAMP_STATE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_MALFUNCTION_INDICATOR_LAMP_STATUS_LAMP__OFF_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_MALFUNCTION_INDICATOR_LAMP_STATUS_LAMP__ON_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_MALFUNCTION_INDICATOR_LAMP_STATUS_SHORT_MIL_FOR_WWH_OBD_CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_MALFUNCTION_INDICATOR_LAMP_STATUS_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_PROTECT_LAMP_SLOW__FLASH_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_PROTECT_LAMP_FAST__FLASH_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_PROTECT_LAMP_RESERVED_CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_PROTECT_LAMP_UNAVAILABLE____DO__NOT__FLASH_CHOICE (3u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_AMBER_WARNING_LAMP_SLOW__FLASH_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_AMBER_WARNING_LAMP_FAST__FLASH_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_AMBER_WARNING_LAMP_RESERVED_CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_AMBER_WARNING_LAMP_UNAVAILABLE____DO__NOT__FLASH_CHOICE (3u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_RED_STOP_LAMP_SLOW__FLASH_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_RED_STOP_LAMP_FAST__FLASH_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_RED_STOP_LAMP_RESERVED_CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_RED_STOP_LAMP_UNAVAILABLE____DO__NOT__FLASH_CHOICE (3u)

#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_MALFUNC_INDICATOR_LAMP_SLOW__FLASH_CHOICE (0u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_MALFUNC_INDICATOR_LAMP_FAST__FLASH_CHOICE (1u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_MALFUNC_INDICATOR_LAMP_CLASS_C_DTC___CHOICE (2u)
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_MALFUNC_INDICATOR_LAMP_UNAVAILABLE____DO__NOT__FLASH_CHOICE (3u)

#define DURA_MAX_TSC1_31_ENG_OVERRIDE_CTRL_MODE_OVERRIDE_DISABLED_CHOICE (0u)
#define DURA_MAX_TSC1_31_ENG_OVERRIDE_CTRL_MODE_SPEED_CONTROL_CHOICE (1u)
#define DURA_MAX_TSC1_31_ENG_OVERRIDE_CTRL_MODE_TORQUE_CONTROL_CHOICE (2u)
#define DURA_MAX_TSC1_31_ENG_OVERRIDE_CTRL_MODE_SPEED_TORQUE_LIMIT_CONTROL_CHOICE (3u)

#define DURA_MAX_TSC1_31_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_TRANSIENT__OPTIMIZED_FOR_DRIVELINE_DISENGAGED_AND_NON_LOCKUP_CONDITIONS_CHOICE (0u)
#define DURA_MAX_TSC1_31_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_DISENGAGED_AND_NON_LOCKUP_CONDITIONS_CHOICE (1u)
#define DURA_MAX_TSC1_31_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_ENGAGED_AND_OR_IN_LOCKUP_CONDITION_1_CHOICE (2u)
#define DURA_MAX_TSC1_31_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_ENGAGED_AND_OR_IN_LOCKUP_CONDITION_2_CHOICE (3u)

#define DURA_MAX_TSC1_31_OVERRIDE_CTRL_MODE_PRIORITY_HIGHEST_PRIORITY_CHOICE (0u)
#define DURA_MAX_TSC1_31_OVERRIDE_CTRL_MODE_PRIORITY_HIGH_PRIORITY_CHOICE (1u)
#define DURA_MAX_TSC1_31_OVERRIDE_CTRL_MODE_PRIORITY_MEDIUM_PRIORITY_CHOICE (2u)
#define DURA_MAX_TSC1_31_OVERRIDE_CTRL_MODE_PRIORITY_LOW_PRIORITY_CHOICE (3u)

#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_1000_MS_TRANSMISSION_RATE_CHOICE (0u)
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_750_MS_TRANSMISSION_RATE_CHOICE (1u)
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_500_MS_TRANSMISSION_RATE_CHOICE (2u)
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_250_MS_TRANSMISSION_RATE_CHOICE (3u)
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_100_MS_TRANSMISSION_RATE_CHOICE (4u)
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_50_MS_TRANSMISSION_RATE_CHOICE (5u)
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_20_MS_TRANSMISSION_RATE_CHOICE (6u)
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_USE_STANDARD_TSC1_TRANSMISSION_RATES_OF_10_MS_TO_ENGINE_CHOICE (7u)

#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P1____ACCELERATOR__PEDAL__OPERATOR__SELECTION_CHOICE (0u)
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P2____CRUISE__CONTROL_CHOICE (1u)
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P3___PTO__GOVERNOR_CHOICE (2u)
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P4____ROAD__SPEED__GOVERNOR_CHOICE (3u)
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P5____ENGINE__PROTECTION_CHOICE (4u)
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P6____TRANSIENT__OPTIMIZED__TORQUE__LIMIT_CHOICE (5u)
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P7____AUTOMATED__DRIVING__SYSTEM__INPUT_CHOICE (6u)
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_P32____TEMPORARY__POWERTRAIN__CONTROL_CHOICE (31u)

#define DURA_MAX_TSC1_31_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_000__CHOICE (0u)
#define DURA_MAX_TSC1_31_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_125__CHOICE (1u)
#define DURA_MAX_TSC1_31_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_875__CHOICE (7u)

#define DURA_MAX_TSC1_03_ENG_OVERRIDE_CTRL_MODE_OVERRIDE_DISABLED_CHOICE (0u)
#define DURA_MAX_TSC1_03_ENG_OVERRIDE_CTRL_MODE_SPEED_CONTROL_CHOICE (1u)
#define DURA_MAX_TSC1_03_ENG_OVERRIDE_CTRL_MODE_TORQUE_CONTROL_CHOICE (2u)
#define DURA_MAX_TSC1_03_ENG_OVERRIDE_CTRL_MODE_SPEED_TORQUE_LIMIT_CONTROL_CHOICE (3u)

#define DURA_MAX_TSC1_03_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_TRANSIENT__OPTIMIZED_FOR_DRIVELINE_DISENGAGED_AND_NON_LOCKUP_CONDITIONS_CHOICE (0u)
#define DURA_MAX_TSC1_03_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_DISENGAGED_AND_NON_LOCKUP_CONDITIONS_CHOICE (1u)
#define DURA_MAX_TSC1_03_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_ENGAGED_AND_OR_IN_LOCKUP_CONDITION_1_CHOICE (2u)
#define DURA_MAX_TSC1_03_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_ENGAGED_AND_OR_IN_LOCKUP_CONDITION_2_CHOICE (3u)

#define DURA_MAX_TSC1_03_OVERRIDE_CTRL_MODE_PRIORITY_HIGHEST_PRIORITY_CHOICE (0u)
#define DURA_MAX_TSC1_03_OVERRIDE_CTRL_MODE_PRIORITY_HIGH_PRIORITY_CHOICE (1u)
#define DURA_MAX_TSC1_03_OVERRIDE_CTRL_MODE_PRIORITY_MEDIUM_PRIORITY_CHOICE (2u)
#define DURA_MAX_TSC1_03_OVERRIDE_CTRL_MODE_PRIORITY_LOW_PRIORITY_CHOICE (3u)

#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_1000_MS_TRANSMISSION_RATE_CHOICE (0u)
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_750_MS_TRANSMISSION_RATE_CHOICE (1u)
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_500_MS_TRANSMISSION_RATE_CHOICE (2u)
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_250_MS_TRANSMISSION_RATE_CHOICE (3u)
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_100_MS_TRANSMISSION_RATE_CHOICE (4u)
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_50_MS_TRANSMISSION_RATE_CHOICE (5u)
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_20_MS_TRANSMISSION_RATE_CHOICE (6u)
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_USE_STANDARD_TSC1_TRANSMISSION_RATES_OF_10_MS_TO_ENGINE_CHOICE (7u)

#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P1____ACCELERATOR__PEDAL__OPERATOR__SELECTION_CHOICE (0u)
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P2____CRUISE__CONTROL_CHOICE (1u)
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P3___PTO__GOVERNOR_CHOICE (2u)
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P4____ROAD__SPEED__GOVERNOR_CHOICE (3u)
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P5____ENGINE__PROTECTION_CHOICE (4u)
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P6____TRANSIENT__OPTIMIZED__TORQUE__LIMIT_CHOICE (5u)
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P7____AUTOMATED__DRIVING__SYSTEM__INPUT_CHOICE (6u)
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_P32____TEMPORARY__POWERTRAIN__CONTROL_CHOICE (31u)

#define DURA_MAX_TSC1_03_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_000__CHOICE (0u)
#define DURA_MAX_TSC1_03_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_125__CHOICE (1u)
#define DURA_MAX_TSC1_03_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_875__CHOICE (7u)

#define DURA_MAX_TSC1_0_B_ENG_OVERRIDE_CTRL_MODE_OVERRIDE_DISABLED_CHOICE (0u)
#define DURA_MAX_TSC1_0_B_ENG_OVERRIDE_CTRL_MODE_SPEED_CONTROL_CHOICE (1u)
#define DURA_MAX_TSC1_0_B_ENG_OVERRIDE_CTRL_MODE_TORQUE_CONTROL_CHOICE (2u)
#define DURA_MAX_TSC1_0_B_ENG_OVERRIDE_CTRL_MODE_SPEED_TORQUE_LIMIT_CONTROL_CHOICE (3u)

#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_TRANSIENT__OPTIMIZED_FOR_DRIVELINE_DISENGAGED_AND_NON_LOCKUP_CONDITIONS_CHOICE (0u)
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_DISENGAGED_AND_NON_LOCKUP_CONDITIONS_CHOICE (1u)
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_ENGAGED_AND_OR_IN_LOCKUP_CONDITION_1_CHOICE (2u)
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_STABILITY__OPTIMIZED_FOR_DRIVELINE_ENGAGED_AND_OR_IN_LOCKUP_CONDITION_2_CHOICE (3u)

#define DURA_MAX_TSC1_0_B_OVERRIDE_CTRL_MODE_PRIORITY_HIGHEST_PRIORITY_CHOICE (0u)
#define DURA_MAX_TSC1_0_B_OVERRIDE_CTRL_MODE_PRIORITY_HIGH_PRIORITY_CHOICE (1u)
#define DURA_MAX_TSC1_0_B_OVERRIDE_CTRL_MODE_PRIORITY_MEDIUM_PRIORITY_CHOICE (2u)
#define DURA_MAX_TSC1_0_B_OVERRIDE_CTRL_MODE_PRIORITY_LOW_PRIORITY_CHOICE (3u)

#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_1000_MS_TRANSMISSION_RATE_CHOICE (0u)
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_750_MS_TRANSMISSION_RATE_CHOICE (1u)
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_500_MS_TRANSMISSION_RATE_CHOICE (2u)
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_250_MS_TRANSMISSION_RATE_CHOICE (3u)
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_100_MS_TRANSMISSION_RATE_CHOICE (4u)
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_50_MS_TRANSMISSION_RATE_CHOICE (5u)
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_20_MS_TRANSMISSION_RATE_CHOICE (6u)
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_USE_STANDARD_TSC1_TRANSMISSION_RATES_OF_10_MS_TO_ENGINE_CHOICE (7u)

#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P1____ACCELERATOR__PEDAL__OPERATOR__SELECTION_CHOICE (0u)
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P2____CRUISE__CONTROL_CHOICE (1u)
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P3___PTO__GOVERNOR_CHOICE (2u)
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P4____ROAD__SPEED__GOVERNOR_CHOICE (3u)
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P5____ENGINE__PROTECTION_CHOICE (4u)
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P6____TRANSIENT__OPTIMIZED__TORQUE__LIMIT_CHOICE (5u)
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P7____AUTOMATED__DRIVING__SYSTEM__INPUT_CHOICE (6u)
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_P32____TEMPORARY__POWERTRAIN__CONTROL_CHOICE (31u)

#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_000__CHOICE (0u)
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_125__CHOICE (1u)
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION__0_875__CHOICE (7u)

#define DURA_MAX_DM07_TEST_IDENTIFIER_ALL_SCALED_TEST_RESULTS_CHOICE (247u)
#define DURA_MAX_DM07_TEST_IDENTIFIER_COMMAND__STANDARD__TEST_CHOICE (249u)
#define DURA_MAX_DM07_TEST_IDENTIFIER_LAST__MEASURED__SCALED__RESULTS_CHOICE (250u)

#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_ABOVE_NORMAL__MOST_SEVERE__CHOICE (0u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_BELOW_NORMAL__MOST_SEVERE__CHOICE (1u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_DATA_ERRATIC_CHOICE (2u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_VOLTAGE_ABOVE_NORMAL_CHOICE (3u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_VOLTAGE_BELOW_NORMAL_CHOICE (4u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_CURRENT_BELOW_NORMAL_CHOICE (5u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_CURRENT_ABOVE_NORMAL_CHOICE (6u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_MECHANICAL_SYSTEM_NOT_RESPONDING_CHOICE (7u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_ABNORMAL_FREQUENCY_CHOICE (8u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_ABNORMAL_UPDATE_RATE_CHOICE (9u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_ABNORMAL_RATE_OF_CHANGE_CHOICE (10u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_ROOT_CAUSE_NOT_KNOWN_CHOICE (11u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_BAD_INTELLIGENT_DEVICE_CHOICE (12u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_OUT_OF_CALIBRATION_CHOICE (13u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_SPECIAL_INTSTRUCTIONS_CHOICE (14u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_ABOVE_NORMAL__LEAST_SEVERE__CHOICE (15u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_ABOVE_NORMAL__MODERATELY_SEVERE__CHOICE (16u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_BELOW_NORMAL__LEAST_SEVERE__CHOICE (17u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_BELOW_NORMAL__MODERATELY_SEVERE__CHOICE (18u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_RECEIVED_NETWORK_DATA_IN_ERROR_CHOICE (19u)
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_NOT_AVAILABLE_CHOICE (31u)

#define DURA_MAX_DM08_TEST_IDENTIFIER_ALL_SCALED_TEST_RESULTS_CHOICE (247u)
#define DURA_MAX_DM08_TEST_IDENTIFIER_COMMAND__STANDARD__TEST_CHOICE (249u)
#define DURA_MAX_DM08_TEST_IDENTIFIER_LAST__MEASURED__SCALED__RESULTS_CHOICE (250u)

#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_BRAKE_ASSIST_SWITCH_RETARDER__BRAKE_ASSIST_DISABLED_CHOICE (0u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_BRAKE_ASSIST_SWITCH_RETARDER__BRAKE_ASSIST_ENABLED_CHOICE (1u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_BRAKE_ASSIST_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_BRAKE_ASSIST_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_SHIFT_ASSIST_SWITCH_RETARDER__SHIFT_ASSIST_DISABLED_CHOICE (0u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_SHIFT_ASSIST_SWITCH_RETARDER__SHIFT_ASSIST_ENABLED_CHOICE (1u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_SHIFT_ASSIST_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_SHIFT_ASSIST_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_ENG_COOLANT_LOAD_INCREASE_NO_COOLANT_LOAD_INCREASE_CHOICE (0u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_ENG_COOLANT_LOAD_INCREASE_COOLANT_LOAD_INCREASE_POSSIBLE_CHOICE (1u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_ENG_COOLANT_LOAD_INCREASE_ERROR_CHOICE (2u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_ENG_COOLANT_LOAD_INCREASE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_REQUESTING_BRAKE_LIGHT_RETARDER_IS_NOT_REQUESTING_THAT_THE_BRAKE_LIGHTS_ARE_ILLUMINATED_CHOICE (0u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_REQUESTING_BRAKE_LIGHT_RETARDER_IS_REQUESTING_THAT_THE_BRAKE_LIGHTS_ARE_ILLUMINATED_CHOICE (1u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_REQUESTING_BRAKE_LIGHT_RESERVED_CHOICE (2u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_REQUESTING_BRAKE_LIGHT_NOT_AVAILABLE__TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_LIMIT_SWITCH_ROAD_SPEED_LIMITING_BY_RETARDER_IS_DISABLED_CHOICE (0u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_LIMIT_SWITCH_ROAD_SPEED_LIMITING_BY_RETARDER_IS_ENABLED_CHOICE (1u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_LIMIT_SWITCH_ERROR__INDICATOR_CHOICE (2u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_LIMIT_SWITCH_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_EXCEEDED_STATUS_ROAD_SPEED_IS_BELOW_THRESHOLD_CHOICE (0u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_EXCEEDED_STATUS_ROAD_SPEED_IS_ABOVE_THRESHOLD_AND_RETARDER_IS_ALLOWED_TO_BE_ACTIVATED_CHOICE (1u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_EXCEEDED_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_EXCEEDED_STATUS_DON_T_CARE__TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_DRIVELINE_ENGAGED_DRIVELINE_DISENGAGED_CHOICE (0u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_DRIVELINE_ENGAGED_DRIVELINE_ENGAGED_CHOICE (1u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_DRIVELINE_ENGAGED_ERROR_CHOICE (2u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_DRIVELINE_ENGAGED_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TORQUE_CONVERTER_LOCKUP_ENGAGED_TORQUE_CONVERTER_LOCKUP_DISENGAGED_CHOICE (0u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TORQUE_CONVERTER_LOCKUP_ENGAGED_TORQUE_CONVERTER_LOCKUP_ENGAGED_CHOICE (1u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TORQUE_CONVERTER_LOCKUP_ENGAGED_ERROR_CHOICE (2u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TORQUE_CONVERTER_LOCKUP_ENGAGED_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_SHIFT_IN_PROCESS_SHIFT_IS_NOT_IN_PROCESS_CHOICE (0u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_SHIFT_IN_PROCESS_SHIFT_IN_PROCESS_CHOICE (1u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_SHIFT_IN_PROCESS_ERROR_CHOICE (2u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_SHIFT_IN_PROCESS_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TRQ_CNVRTR_LCKP_TRNSTN_IN_PROCESS_TRANSITION_IS_NOT_IN_PROCESS_CHOICE (0u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TRQ_CNVRTR_LCKP_TRNSTN_IN_PROCESS_TRANSITION_IS_IN_PROCESS_CHOICE (1u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TRQ_CNVRTR_LCKP_TRNSTN_IN_PROCESS_ERROR_CHOICE (2u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TRQ_CNVRTR_LCKP_TRNSTN_IN_PROCESS_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_ENG_MOMENTARY_OVERSPEED_ENABLE_MOMENTARY_ENGINE_OVERSPEED_IS_DISABLED_CHOICE (0u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_ENG_MOMENTARY_OVERSPEED_ENABLE_MOMENTARY_ENGINE_OVERSPEED_IS_ENABLED_CHOICE (1u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_ENG_MOMENTARY_OVERSPEED_ENABLE_RESERVED_CHOICE (2u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_ENG_MOMENTARY_OVERSPEED_ENABLE_TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_PROGRESSIVE_SHIFT_DISABLE_PROGRESSIVE_SHIFT_IS_NOT_DISABLED_CHOICE (0u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_PROGRESSIVE_SHIFT_DISABLE_PROGRESSIVE_SHIFT_IS_DISABLED_CHOICE (1u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_PROGRESSIVE_SHIFT_DISABLE_RESERVED_CHOICE (2u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_PROGRESSIVE_SHIFT_DISABLE_TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_MOMENTARY_ENG_MAX_POWER_ENABLE_NOT_REQUESTING_MAXIMUM_POWER_AVAILABLE_CHOICE (0u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_MOMENTARY_ENG_MAX_POWER_ENABLE_MOMENTARILY_REQUESTING_MAXIMUM_POWER_AVAILABLE_CHOICE (1u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_MOMENTARY_ENG_MAX_POWER_ENABLE_FAULT_CHOICE (2u)
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_MOMENTARY_ENG_MAX_POWER_ENABLE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_2_WHEEL_HIGH_CHOICE (0u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_4_WHEEL_HIGH_CHOICE (1u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_NEUTRAL_CHOICE (2u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_2_WHEEL_LOW_CHOICE (3u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_4_WHEEL_LOW_CHOICE (4u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_TRANSFER__CASE__SHIFT_IN__PROGRESS_OR_GEAR_NOT_CONFIRMED_CHOICE (5u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_ERROR_CHOICE (6u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_NOT_AVAILABLE_CHOICE (7u)

#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_DIR_STATUS_FORWARD_CHOICE (0u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_DIR_STATUS_REVERSE_CHOICE (1u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_DIR_STATUS_ERROR_CHOICE (2u)
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_DIR_STATUS_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_LESS_THAN_1_MINUTE_CHOICE (0u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_ONE_MINUTE_CHOICE (1u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_TWO_MINUTES_CHOICE (2u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_THREE_MINUTES_CHOICE (3u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_FOUR_MINUTES_CHOICE (4u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_FIVE_MINUTES_CHOICE (5u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_SIX_MINUTES_CHOICE (6u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_SEVEN_MINUTES_CHOICE (7u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_EIGHT_MINUTES_CHOICE (8u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_NINE_MINUTES_CHOICE (9u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_TEN_MINUTES_CHOICE (10u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_ELEVEN_MINUTES_CHOICE (11u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_TWELVE_MINUTES_CHOICE (12u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_THIRTEEN_MINUTES_CHOICE (13u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_ERROR_CHOICE (14u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_NOT__AVAILABLE_CHOICE (15u)

#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_VALID_FOR_TRANSMISSION_OIL_LEVEL_MEASUREMENT_CHOICE (0u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___SETTLING_TIMER_STILL_COUNTING_DOWN_CHOICE (1u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___TRANSMISSION_IN_GEAR_CHOICE (2u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___TRANSMISSION_FLUID_TEMPERATURE_TOO_LOW_CHOICE (3u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___TRANSMISSION_FLUID_TEMPERATURE_TOO_HIGH_CHOICE (4u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___VEHICLE_MOVING_CHOICE (5u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___VEHICLE_NOT_LEVEL_CHOICE (6u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___ENGINE_SPEED_TOO_LOW_CHOICE (7u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___ENGINE_SPEED_TOO_HIGH_CHOICE (8u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___NO_REQUEST_FOR_READING_CHOICE (9u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_NOT_DEFINED_10_CHOICE (10u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_NOT_DEFINED_11_CHOICE (11u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_NOT_DEFINED_12_CHOICE (12u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_CONDITIONS_NOT_VALID___OTHER_CHOICE (13u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_ERROR_CHOICE (14u)
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_NOT_AVAILABLE_CHOICE (15u)

#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_DIS_CMD_SUPPORT_SYSTEM_DOES_NOT_SUPPORT_THE___CRUISE__CONTROL__DISABLE__COMMAND__CHOICE (0u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_DIS_CMD_SUPPORT_SYSTEM_DOES_SUPPORT_THE___CRUISE__CONTROL__DISABLE__COMMAND__FEATURE_CHOICE (1u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_DIS_CMD_SUPPORT_RESERVED_CHOICE (2u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_DIS_CMD_SUPPORT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_RESUME_CMD_SUPPORT_SYSTEM_DOES_NOT_SUPPORT_THE___CRUISE__CONTROL__RESUME__COMMAND__FEATURE_CHOICE (0u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_RESUME_CMD_SUPPORT_SYSTEM_DOES_SUPPORT_THE___CRUISE__CONTROL__RESUME__COMMAND__FEATURE_CHOICE (1u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_RESUME_CMD_SUPPORT_ERROR_CHOICE (2u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_RESUME_CMD_SUPPORT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_PAUSE_CMD_SUPPORT_SYSTEM_DOES_NOT_SUPPORT_THE___CRUISE__CONTROL__PAUSE__COMMAND__FEATURE_CHOICE (0u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_PAUSE_CMD_SUPPORT_SYSTEM_DOES_SUPPORT_THE___CRUISE__CONTROL__PAUSE__COMMAND__FEATURE_CHOICE (1u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_PAUSE_CMD_SUPPORT_ERROR_CHOICE (2u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_PAUSE_CMD_SUPPORT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_SET_CMD_SUPPORT_SYSTEM_DOES_NOT_SUPPORT_THE___CRUISE__CONTROL__SET__COMMAND__FEATURE_CHOICE (0u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_SET_CMD_SUPPORT_SYSTEM_DOES_SUPPORT_THE___CRUISE__CONTROL__SET__COMMAND__FEATURE_CHOICE (1u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_SET_CMD_SUPPORT_ERROR_CHOICE (2u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_SET_CMD_SUPPORT_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_CONTROLLER_DOES_NOT_SUPPORT_SYSTEM_BASED_CRUISE_CONTROL__PAUSE__RESUME_CHOICE (0u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_AUTO__RESUME_CHOICE (1u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_STOP_AND__OPERATOR__GO_CHOICE (2u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_STOP_AND__AUTO__GO_CHOICE (3u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_4_CHOICE (4u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_5_CHOICE (5u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_6_CHOICE (6u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_7_CHOICE (7u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_8_CHOICE (8u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_9_CHOICE (9u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_10_CHOICE (10u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_11_CHOICE (11u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_12_CHOICE (12u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_13_CHOICE (13u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_RESERVED_14_CHOICE (14u)
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_NOT__AVAILABLE_CHOICE (15u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_TWO_SPEED_AXLE_SWITCH_LOW_SPEED_RANGE_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_TWO_SPEED_AXLE_SWITCH_HIGH_SPEED_RANGE_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_TWO_SPEED_AXLE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_TWO_SPEED_AXLE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARKING_BRAKE_SWITCH_PARKING_BRAKE_NOT_SET_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARKING_BRAKE_SWITCH_PARKING_BRAKE_SET_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARKING_BRAKE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARKING_BRAKE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_PAUSE_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_PAUSE_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_PAUSE_SWITCH_ERROR__INDICATOR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_PAUSE_SWITCH_TAKE__NO__ACTION_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARK_BRAKE_RELEASE_INHIBIT_RQ_PARK__BRAKE__RELEASE__INHIBIT_NOT_REQUESTED_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARK_BRAKE_RELEASE_INHIBIT_RQ_PARK__BRAKE__RELEASE__INHIBIT_REQUESTED_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARK_BRAKE_RELEASE_INHIBIT_RQ_SAE_RESERVED_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARK_BRAKE_RELEASE_INHIBIT_RQ_UNAVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACTIVE_CRUISE_CONTROL_SWITCHED_OFF_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACTIVE_CRUISE_CONTROL_SWITCHED_ON_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACTIVE_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACTIVE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ENABLE_SWITCH_CRUISE_CONTROL_DISABLED_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ENABLE_SWITCH_CRUISE_CONTROL_ENABLED_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ENABLE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ENABLE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_BRAKE_SWITCH_BRAKE_PEDAL_RELEASED_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_BRAKE_SWITCH_BRAKE_PEDAL_DEPRESSED_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_BRAKE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_BRAKE_SWITCH_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CLUTCH_SWITCH_CLUTCH_PEDAL_RELEASED_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CLUTCH_SWITCH_CLUTCH_PEDAL_DEPRESSED_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CLUTCH_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CLUTCH_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_SET_SWITCH_CRUISE_CONTROL_ACTIVATOR_NOT_IN_THE_POSITION__SET__CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_SET_SWITCH_CRUISE_CONTROL_ACTIVATOR_IN_POSITION__SET__CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_SET_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_SET_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_COAST_SWITCH_CRUISE_CONTROL_ACTIVATOR_NOT_IN_THE_POSITION__COAST__CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_COAST_SWITCH_CRUISE_CONTROL_ACTIVATOR_IN_POSITION__COAST__CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_COAST_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_COAST_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_RESUME_SWITCH_CRUISE_CONTROL_ACTIVATOR_NOT_IN_THE_POSITION__RESUME__CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_RESUME_SWITCH_CRUISE_CONTROL_ACTIVATOR_IN_POSITION__RESUME__CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_RESUME_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_RESUME_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACCELERATE_SWITCH_CRUISE_CONTROL_ACTIVATOR_NOT_IN_THE_POSITION__ACCELERATE__CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACCELERATE_SWITCH_CRUISE_CONTROL_ACTIVATOR_IN_POSITION__ACCELERATE__CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACCELERATE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACCELERATE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_OFF__DISABLED_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_HOLD_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_REMOTE__HOLD_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_STANDBY_CHOICE (3u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_REMOTE__STANDBY_CHOICE (4u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_SET_CHOICE (5u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_DECELERATE__COAST_CHOICE (6u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESUME_CHOICE (7u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_ACCELERATE_CHOICE (8u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_ACCELERATOR__OVERRIDE_CHOICE (9u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_1_CHOICE (10u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_2_CHOICE (11u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_3_CHOICE (12u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_4_CHOICE (13u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_5_CHOICE (14u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_6_CHOICE (15u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_7_CHOICE (16u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PREPROGRAMMED_SET_SPEED_8_CHOICE (17u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PTO_SET_SPEED_MEMORY_1_CHOICE (18u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PTO_SET_SPEED_MEMORY_2_CHOICE (19u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_PTO_SET_SPEED_MEMORY_3_CHOICE (20u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_21_CHOICE (21u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_22_CHOICE (22u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_23_CHOICE (23u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_24_CHOICE (24u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_25_CHOICE (25u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_26_CHOICE (26u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_27_CHOICE (27u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_28_CHOICE (28u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESERVED_29_CHOICE (29u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_RESEERVED_CHOICE (30u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_NOT_AVAILABLE_CHOICE (31u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_OFF__DISABLED_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_HOLD_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_ACCELERATE_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_DECELERATE_CHOICE (3u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_RESUME_CHOICE (4u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_SET_CHOICE (5u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_ACCELERATOR__OVERRIDE_CHOICE (6u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_NOT_AVAILABLE_CHOICE (7u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_INCREMENT_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_INCREMENT_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_INCREMENT_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_INCREMENT_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_DECREMENT_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_DECREMENT_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_DECREMENT_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_DECREMENT_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_TEST_MODE_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_TEST_MODE_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_TEST_MODE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_TEST_MODE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_SHUTDOWN_OVERRIDE_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_SHUTDOWN_OVERRIDE_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_SHUTDOWN_OVERRIDE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_SHUTDOWN_OVERRIDE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_ENG_CTRL_ACTIVE_ASR_ENGINE_CONTROL_PASSIVE_BUT_INSTALLED_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_ENG_CTRL_ACTIVE_ASR_ENGINE_CONTROL_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_ENG_CTRL_ACTIVE_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_ENG_CTRL_ACTIVE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_BRAKE_CTRL_ACTIVE_ASR_BRAKE_CONTROL_PASSIVE_BUT_INSTALLED_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_BRAKE_CTRL_ACTIVE_ASR_BRAKE_CONTROL_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_BRAKE_CTRL_ACTIVE_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_BRAKE_CTRL_ACTIVE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ANTI_LOCK_BRAKING_ACTIVE_ABS_PASSIVE_BUT_INSTALLED_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ANTI_LOCK_BRAKING_ACTIVE_ABS_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ANTI_LOCK_BRAKING_ACTIVE_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ANTI_LOCK_BRAKING_ACTIVE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_BRAKE_SWITCH_BRAKE_PEDAL_IS_NOT_BEING_PRESSED_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_BRAKE_SWITCH_BRAKE_PEDAL_IS_BEING_PRESSED_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_BRAKE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_BRAKE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_OFFROAD_SWITCH_ABS_OFF_ROAD_SWITCH_PASSIVE_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_OFFROAD_SWITCH_ABS_OFF_ROAD_SWITCH_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_OFFROAD_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_OFFROAD_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_OFFROAD_SWITCH_ASR_OFF_ROAD_SWITCH_PASSIVE_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_OFFROAD_SWITCH_ASR_OFF_ROAD_SWITCH_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_OFFROAD_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_OFFROAD_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_HILL_HOLDER_SWITCH_ASR__HILL_HOLDER__SWITCH_PASSIVE_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_HILL_HOLDER_SWITCH_ASR__HILL_HOLDER__SWITCH_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_HILL_HOLDER_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_HILL_HOLDER_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRACTION_CTRL_OVERRIDE_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRACTION_CTRL_OVERRIDE_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRACTION_CTRL_OVERRIDE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRACTION_CTRL_OVERRIDE_SWITCH_NOT_AVAILABLE_OR_NOT_INSTALLED_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ACCEL_INTERLOCK_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ACCEL_INTERLOCK_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ACCEL_INTERLOCK_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ACCEL_INTERLOCK_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_DERATE_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_DERATE_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_DERATE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_DERATE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_AUX_SHUTDOWN_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_AUX_SHUTDOWN_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_AUX_SHUTDOWN_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_AUX_SHUTDOWN_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_REMOTE_ACCEL_ENABLE_SWITCH_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_REMOTE_ACCEL_ENABLE_SWITCH_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_REMOTE_ACCEL_ENABLE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_REMOTE_ACCEL_ENABLE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_FULLY_OPERATIONAL_NOT__FULLY__OPERATIONAL_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_FULLY_OPERATIONAL_FULLY__OPERATIONAL_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_FULLY_OPERATIONAL_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_FULLY_OPERATIONAL_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_RED_WARNING_SIGNAL_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_RED_WARNING_SIGNAL_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_RED_WARNING_SIGNAL_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_RED_WARNING_SIGNAL_TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_EBS_AMBER_WARNING_SIGNAL_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_EBS_AMBER_WARNING_SIGNAL_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_EBS_AMBER_WARNING_SIGNAL_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_EBS_AMBER_WARNING_SIGNAL_TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ATC_ASR_INFORMATION_SIGNAL_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ATC_ASR_INFORMATION_SIGNAL_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ATC_ASR_INFORMATION_SIGNAL_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ATC_ASR_INFORMATION_SIGNAL_TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_RAILROAD_MODE_SW_RAILROAD_MODE_SWITCH_PASSIVE_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_RAILROAD_MODE_SW_RAILROAD_MODE_SWITCH_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_RAILROAD_MODE_SW_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_RAILROAD_MODE_SW_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_HALT_BRAKE_SWITCH_HALT_BRAKE_SWITCH_PASSIVE_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_HALT_BRAKE_SWITCH_HALT_BRAKE_SWITCH_ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_HALT_BRAKE_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_HALT_BRAKE_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRAILER_ABS_STATUS_TRAILER_ABS__STATUS__INFORMATION__AVAILABLE__BUT__NOT__ACTIVE_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRAILER_ABS_STATUS_TRAILER_ABS__ACTIVE_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRAILER_ABS_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRAILER_ABS_STATUS_TRAILER_ABS__STATUS__INFORMATION__NOT__AVAILABLE_OR__PARAMETER__NOT__SUPPORTED_CHOICE (3u)

#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRCTR_MNTD_TRAILER_ABS_WARNING_SIGNAL_OFF_CHOICE (0u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRCTR_MNTD_TRAILER_ABS_WARNING_SIGNAL_ON_CHOICE (1u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRCTR_MNTD_TRAILER_ABS_WARNING_SIGNAL_RESERVED_CHOICE (2u)
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRCTR_MNTD_TRAILER_ABS_WARNING_SIGNAL_TAKE_NO_ACTION_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_HAS_SHUTDOWN_ENG_NO_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_HAS_SHUTDOWN_ENG_YES_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_HAS_SHUTDOWN_ENG_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_HAS_SHUTDOWN_ENG_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_DRIVER_ALERT_MODE_INACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_DRIVER_ALERT_MODE_ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_DRIVER_ALERT_MODE_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_DRIVER_ALERT_MODE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_OVERRIDE_INACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_OVERRIDE_ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_OVERRIDE_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_OVERRIDE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_STATE_INACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_STATE_ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_STATE_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_STATE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_FUNCTION_DISABLED_IN_CALIBRATION_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_FUNCTION_ENABLED_IN_CALIBRATION_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_FUNCTION_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_FUNCTION_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_A_C_HIGH_PRESS_FAN_SWITCH_PRESSURE_NORMAL_CHOICE (0u)
#define DURA_MAX_SHUTDN_A_C_HIGH_PRESS_FAN_SWITCH_PRESSURE_HIGH_CHOICE (1u)
#define DURA_MAX_SHUTDN_A_C_HIGH_PRESS_FAN_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_A_C_HIGH_PRESS_FAN_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_REFRIGERANT_LOW_PRESS_SWITCH_PRESSURE_NORMAL_CHOICE (0u)
#define DURA_MAX_SHUTDN_REFRIGERANT_LOW_PRESS_SWITCH_PRESSURE_TOO_LOW_CHOICE (1u)
#define DURA_MAX_SHUTDN_REFRIGERANT_LOW_PRESS_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_REFRIGERANT_LOW_PRESS_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_REFRIGERANT_HIGH_PRESS_SWITCH_PRESSURE_NORMAL_CHOICE (0u)
#define DURA_MAX_SHUTDN_REFRIGERANT_HIGH_PRESS_SWITCH_PRESSURE_TOO_HIGH_CHOICE (1u)
#define DURA_MAX_SHUTDN_REFRIGERANT_HIGH_PRESS_SWITCH_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_REFRIGERANT_HIGH_PRESS_SWITCH_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_WAIT_TO_START_LAMP_OFF_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_WAIT_TO_START_LAMP_ON_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_WAIT_TO_START_LAMP_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_WAIT_TO_START_LAMP_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_PRTECTION_SYSTEM_HAS_SHUTDOWN_ENG_NO_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_PRTECTION_SYSTEM_HAS_SHUTDOWN_ENG_YES_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_PRTECTION_SYSTEM_HAS_SHUTDOWN_ENG_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_PRTECTION_SYSTEM_HAS_SHUTDOWN_ENG_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_PRTCTN_SYSTM_APPRACHING_SHUTDOWN_NOT_APPROACHING_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_PRTCTN_SYSTM_APPRACHING_SHUTDOWN_APPROACHING_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_PRTCTN_SYSTM_APPRACHING_SHUTDOWN_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_PRTCTN_SYSTM_APPRACHING_SHUTDOWN_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_OVERRIDE_INACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_OVERRIDE_ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_OVERRIDE_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_OVERRIDE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_STATE_INACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_STATE_ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_STATE_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_STATE_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_CONFIG_DISABLED_IN_CALIBRATION_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_CONFIG_ENABLED_IN_CALIBRATION_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_CONFIG_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_CONFIG_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_ALARM_ACKNOWLEDGE_ENGINE__ALARM__ACKNOWLEDGE___NOT__ACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_ALARM_ACKNOWLEDGE_ENGINE__ALARM__ACKNOWLEDGE__ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_ALARM_ACKNOWLEDGE_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_ALARM_ACKNOWLEDGE_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_ALARM_OUTPUT_CMD_STATUS_ENGINE__ALARM__OUTPUT__COMMAND__NOT__ACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_ALARM_OUTPUT_CMD_STATUS_ENGINE__ALARM__OUTPUT__COMMAND__ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_ALARM_OUTPUT_CMD_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_ALARM_OUTPUT_CMD_STATUS_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_CMD_STATUS_AIR__SHUTOFF__DISABLED_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_CMD_STATUS_AIR__SHUTOFF__ENABLED_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_CMD_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_CMD_STATUS_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_OVERSPEED_TEST_ENGINE__OVERSPEED__TEST__NOT__ACTIVE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_OVERSPEED_TEST_ENGINE__OVERSPEED__TEST__ACTIVE_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_OVERSPEED_TEST_RESERVED_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_OVERSPEED_TEST_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_STATUS_AIR_FLOW_ALLOWED_TO_ENGINE_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_STATUS_AIR_FLOW_RESTRICTED_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_STATUS_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_STATUS_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_PTO_SHUTDOWN_HAS_SHUTDOWN_ENG_NO_CHOICE (0u)
#define DURA_MAX_SHUTDN_PTO_SHUTDOWN_HAS_SHUTDOWN_ENG_YES_CHOICE (1u)
#define DURA_MAX_SHUTDN_PTO_SHUTDOWN_HAS_SHUTDOWN_ENG_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_PTO_SHUTDOWN_HAS_SHUTDOWN_ENG_NOT_AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_CLNT_LVL_ENG_PRTCTION_SHUTDOWN_STATUS_DISABLED_CHOICE (0u)
#define DURA_MAX_SHUTDN_CLNT_LVL_ENG_PRTCTION_SHUTDOWN_STATUS_ENABLED_CHOICE (1u)
#define DURA_MAX_SHUTDN_CLNT_LVL_ENG_PRTCTION_SHUTDOWN_STATUS_RESERVED_CHOICE (2u)
#define DURA_MAX_SHUTDN_CLNT_LVL_ENG_PRTCTION_SHUTDOWN_STATUS_NOT__AVAILABLE_CHOICE (3u)

#define DURA_MAX_SHUTDN_ENG_OIL_PRESS_SW_OK_CHOICE (0u)
#define DURA_MAX_SHUTDN_ENG_OIL_PRESS_SW_NOT_OK_CHOICE (1u)
#define DURA_MAX_SHUTDN_ENG_OIL_PRESS_SW_ERROR_CHOICE (2u)
#define DURA_MAX_SHUTDN_ENG_OIL_PRESS_SW_NOT__AVAILABLE_CHOICE (3u)

/* Frame Names. */
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_NAME "EEC5_Electronic_Engine_Control_5"
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_NAME "EEC9_Electronic_Engine_Control_9"
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_NAME "EBCC_Engine_Exhaust_Brake_Cont"
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_NAME "ET3_Engine_Temperature_3"
#define DURA_MAX_DM21_DIAGNOSTIC_READINESS_2_NAME "DM21_Diagnostic_Readiness_2"
#define DURA_MAX_DM26_DIAGNOSTIC_READINESS_3_NAME "DM26_Diagnostic_Readiness_3"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_NAME "IC1_Intake_Exhaust_Cond_1"
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_NAME "AMB_Ambient_Conditions"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_NAME "EEC1_Electronic_Engine_Control_1"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_NAME "EEC2_Electronic_Engine_Control_2"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_NAME "EEC3_Electronic_Engine_Control_3"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_NAME "EFL_P1_Eng_Fluid_Level_Press_1"
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_NAME "EFL_P2_Eng_Fluid_Level_Press_2"
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_NAME "ET1_Engine_Temperature_1"
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_NAME "LFE1_Fuel_Economy_Liquid_1"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_NAME "TransportProtocol_Header"
#define DURA_MAX_TRANSPORT_PROTOCOL_DATA_NAME "TransportProtocol_Data"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_NAME "DM01_Active_Diagnostics"
#define DURA_MAX_TSC1_31_NAME "TSC1_31"
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_NAME "CAC1_Charge_Air_Cooler_1"
#define DURA_MAX_HOURS_ENGINE_HOURS_REVOLUTIONS_NAME "HOURS_Engine_Hours_Revolutions"
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_NAME "TCI5_Turbocharger_Information_5"
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_NAME "VEP1_Vehicle_Electrical_Power_1"
#define DURA_MAX_EEC20_ELECTRONIC_ENGINE_CONTROL__NAME "EEC20_Electronic_Engine_Control_"
#define DURA_MAX_EASI_ENGINE_AIR_SYSTEM_INFO_NAME "EASI_Engine_Air_System_Info"
#define DURA_MAX_TSC1_03_NAME "TSC1_03"
#define DURA_MAX_TSC1_0_B_NAME "TSC1_0B"
#define DURA_MAX_DM07_NAME "DM07"
#define DURA_MAX_DM08_NAME "DM08"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_NAME "ERC1_Electronic_Retarder_Cntrl"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_NAME "ETC1_Electronic_Trans_Cntrl_1"
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_NAME "ETC2_Electronic_Trans_Cntrl_2"
#define DURA_MAX_RQST_00_5_E_NAME "RQST_00_5E"
#define DURA_MAX_RQST_00_21_NAME "RQST_00_21"
#define DURA_MAX_RQST_GLOBAL_5_E_NAME "RQST_Global_5E"
#define DURA_MAX_RQST_GLOBAL_03_NAME "RQST_Global_03"
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_NAME "TCI_Transfer_Case_Information"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_NAME "TRF1_Transmission_Fluids_1"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_NAME "CCSS_Cruise_Control_Vehicle_Spd"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_NAME "CCVS1__Cruise_Control_VehSpd"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_NAME "EBC1_Electronic_Brake_Cntrl"
#define DURA_MAX_SHUTDN_NAME "SHUTDN"

/* Signal Names. */
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_TURBOCHARGER_1_CALCULATED_NAME "Engine_Turbocharger_1_Calculated"
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_COMMANDED_VGT_POSITION_NAME "Commanded_VGT_Position"
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_VARIABLE_GEOMETRY_TURBOCH_NAME "Engine_Variable_Geometry_Turboch"
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_FUEL_CONTROL_CONTROL_MODE_NAME "Engine_Fuel_Control_Control_Mode"
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ENGINE_VGT_CONTROL_MODE_NAME "Engine_VGT_Control_Mode"
#define DURA_MAX_EEC5_ELECTRONIC_ENGINE_CONTROL_5_ACTUAL_VGT_POSITION_NAME "Actual_VGT_Position"
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_ENGINE_EXHAUST_GAS_RECIRCULATION_NAME "Engine_Exhaust_Gas_Recirculation"
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_COMMANDED_FUEL_RAIL_PRESSURE_NAME "Commanded_Fuel_Rail_Pressure"
#define DURA_MAX_EEC9_ELECTRONIC_ENGINE_CONTROL_9_COMMANDED_ENGINE_FUEL_INJECTION__NAME "Commanded_Engine_Fuel_Injection_"
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_ACTUAL_BOOST_PRESSURE_NAME "Actual_Boost_Pressure"
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_DESIRED_BOOST_PRESSURE_NAME "Desired_Boost_Pressure"
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_ENGINE_EXHAUST_BRAKE_ACTUATOR_CO_NAME "Engine_Exhaust_Brake_Actuator_Co"
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_ENGINE_TURBOCHARGER_2_TURBINE_OU_NAME "Engine_Turbocharger_2_Turbine_Ou"
#define DURA_MAX_EBCC_ENGINE_EXHAUST_BRAKE_CONT_DESIRED_ENGINE_TURBOCHARGER_2_TU_NAME "Desired_Engine_Turbocharger_2_Tu"
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_ENGINE_INTAKE_MANIFOLD_1_AIR_TEM_NAME "Engine_Intake_Manifold_1_Air_Tem"
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_ENGINE_COOLANT_TEMPERATURE_HIGH_NAME "Engine_Coolant_Temperature__High"
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_ENGINE_INTAKE_VALVE_ACTUATION_SY_NAME "Engine_Intake_Valve_Actuation_Sy"
#define DURA_MAX_ET3_ENGINE_TEMPERATURE_3_ENGINE_CAC_OUTLET_TEMPERATURE_NAME "Engine_CAC_Outlet_Temperature"
#define DURA_MAX_DM21_DIAGNOSTIC_READINESS_2_ENGINE_RUN_TIME_WITH_MIL_ON_NAME "Engine_Run_Time_With_MIL_On"
#define DURA_MAX_DM26_DIAGNOSTIC_READINESS_3_TIME_SINCE_ENGINE_START_NAME "Time_Since_Engine_Start"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_AFT1_DPF_IN_PRESS_NAME "AFT1DPFInPress"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_ENG_INTAKE_MANIFOLD1_PRESS_NAME "EngIntakeManifold1Press"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_ENG_INTAKE_MANIFOLD1_TEMP_NAME "EngIntakeManifold1Temp"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_ENG_AIR_INTAKE_PRESS_NAME "EngAirIntakePress"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_ENG_AIR_FILTER1_DIFF_PRESS_NAME "EngAirFilter1DiffPress"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_ENG_EXHAUST_GAS_TEMP_NAME "EngExhaustGasTemp"
#define DURA_MAX_IC1_INTAKE_EXHAUST_COND_1_ENG_COOLANT_FILTER_DIFF_PRESS_NAME "EngCoolantFilterDiffPress"
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_BAROMETRIC_PRESSURE_BAROMETRIC_PR_NAME "Barometric_PressureBarometric_Pr"
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_CAB_INTERIOR_TEMP_NAME "CabInteriorTemp"
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_AMBIENT_AIR_TEMPERATURE_NAME "Ambient_Air_Temperature"
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_ENGINE_AIR_INTAKE_TEMPERATURE_NAME "Engine_Air_Intake_Temperature"
#define DURA_MAX_AMB_AMBIENT_CONDITIONS_ROAD_SURFACE_TEMP_NAME "RoadSurfaceTemp"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENGINE_TORQUE_MODE_NAME "Engine_Torque_Mode"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ACTL_ENG_PRCNT_TORQUE_HIGH_RESOLUTION_NAME "ActlEngPrcntTorqueHighResolution"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_DRIVERS_DEMAND_ENGINE_PRCNT_TORQ_NAME "Drivers_Demand_Engine_Prcnt_Torq"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ACTUAL_ENGINE_PERCENT_TORQUE_NAME "Actual_Engine_Percent_Torque"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENGINE_SPEED_NAME "Engine_Speed"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_SRC_ADDRSS_OF_CNTRLLNG_DVC_FOR_ENG_CTRL_NAME "SrcAddrssOfCntrllngDvcForEngCtrl"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENG_STARTER_MODE_NAME "EngStarterMode"
#define DURA_MAX_EEC1_ELECTRONIC_ENGINE_CONTROL_1_ENGINE_DEMAND_PERCENT_TORQUE_NAME "Engine_Demand_Percent_Torque"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL1_LOW_IDLE_SWITCH_NAME "AccelPedal1LowIdleSwitch"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL_KICKDOWN_SWITCH_NAME "AccelPedalKickdownSwitch"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ROAD_SPEED_LIMIT_STATUS_NAME "RoadSpeedLimitStatus"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL2_LOW_IDLE_SWITCH_NAME "AccelPedal2LowIdleSwitch"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL_POS1_NAME "AccelPedalPos1"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ENG_PERCENT_LOAD_AT_CURRENT_SPEED_NAME "EngPercentLoadAtCurrentSpeed"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_REMOTE_ACCEL_PEDAL_POS_NAME "RemoteAccelPedalPos"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACCEL_PEDAL_POS2_NAME "AccelPedalPos2"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_VHCLE_ACCELERATION_RATE_LIMIT_STATUS_NAME "VhcleAccelerationRateLimitStatus"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_MMNTARY_ENG_MAX_POWER_ENABLE_FEEDBACK_NAME "MmntaryEngMaxPowerEnableFeedback"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_DPF_THERMAL_MANAGEMENT_ACTIVE_NAME "DPFThermalManagementActive"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_SCR_THERMAL_MANAGEMENT_ACTIVE_NAME "SCRThermalManagementActive"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_ACTL_MAX_AVAILABLE_ENG_PERCENT_TORQUE_NAME "ActlMaxAvailableEngPercentTorque"
#define DURA_MAX_EEC2_ELECTRONIC_ENGINE_CONTROL_2_EST_PUMPING_PERCENT_TORQUE_NAME "EstPumpingPercentTorque"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_NOMINAL_FRICTION_PERCENT_TORQUE_NAME "NominalFrictionPercentTorque"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_ENGINES_DESIRED_OPERATING_SPEED_NAME "EnginesDesiredOperatingSpeed"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_ENGNS_DSRD_OPRTNG_SPD_ASYMMTRY_ADJSTM_NAME "EngnsDsrdOprtngSpdAsymmtryAdjstm"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_EST_ENG_PRSITIC_LOSSES_PERCENT_TORQUE_NAME "EstEngPrsiticLossesPercentTorque"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_EXH_GAS_MFR_NAME "AFT1ExhGasMFR"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_IN_DEW_POINT_NAME "AFT1InDewPoint"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT1_EXH_DEW_POINT_NAME "AFT1ExhDewPoint"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_IN_DEW_POINT_NAME "AFT2InDewPoint"
#define DURA_MAX_EEC3_ELECTRONIC_ENGINE_CONTROL_3_AFT2_EXH_DEW_POINT_NAME "AFT2ExhDewPoint"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_ENG_FUEL_DELIVERY_PRESS_NAME "EngFuelDeliveryPress"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_ENG_EX_CRANKCASE_BLOWBY_PRESS_NAME "EngExCrankcaseBlowbyPress"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_ENG_OIL_LEVEL_NAME "EngOilLevel"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_ENG_OIL_PRESS_NAME "EngOilPress"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_ENG_CRANKCASE_PRESS_NAME "EngCrankcasePress"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_ENG_COOLANT_PRESS_NAME "EngCoolantPress"
#define DURA_MAX_EFL_P1_ENG_FLUID_LEVEL_PRESS_1_ENG_COOLANT_LEVEL_NAME "EngCoolantLevel"
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_ENG_INJECTION_CTRL_PRESS_NAME "EngInjectionCtrlPress"
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_ENG_INJECTOR_METERING_RAIL1_PRESS_NAME "EngInjectorMeteringRail1Press"
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_ENG_INJECTOR_TIMING_RAIL1_PRESS_NAME "EngInjectorTimingRail1Press"
#define DURA_MAX_EFL_P2_ENG_FLUID_LEVEL_PRESS_2_ENG_INJECTOR_METERING_RAIL2_PRESS_NAME "EngInjectorMeteringRail2Press"
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_ENG_COOLANT_TEMP_NAME "EngCoolantTemp"
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_ENG_FUEL_TEMP1_NAME "EngFuelTemp1"
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_ENG_OIL_TEMP1_NAME "EngOilTemp1"
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_ENG_TURBO_OIL_TEMP_NAME "EngTurboOilTemp"
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_ENG_INTERCOOLER_TEMP_NAME "EngIntercoolerTemp"
#define DURA_MAX_ET1_ENGINE_TEMPERATURE_1_ENG_INTERCOOLER_THERMOSTAT_OPENING_NAME "EngIntercoolerThermostatOpening"
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_ENG_FUEL_RATE_NAME "EngFuelRate"
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_ENG_INSTANTANEOUS_FUEL_ECONOMY_NAME "EngInstantaneousFuelEconomy"
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_ENG_AVERAGE_FUEL_ECONOMY_NAME "EngAverageFuelEconomy"
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_ENG_THROTTLE_VALVE1_POS_NAME "EngThrottleValve1Pos"
#define DURA_MAX_LFE1_FUEL_ECONOMY_LIQUID_1_ENG_THROTTLE_VALVE2_POS_NAME "EngThrottleValve2Pos"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONTROL_BYTE_NAME "ControlByte"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_TOTAL_MESSAGE_SIZE_EO_MA_NAME "TotalMessageSizeEoMA"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_CONNECTION_ABORT_REASON_NAME "ConnectionAbortReason"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_TOTAL_MESSAGE_SIZE_NAME "TotalMessageSize"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_NUMBER_OF_PACKETS_THAT_CAN_BE_SENT_NAME "NumberOfPacketsThatCanBeSent"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_TOTAL_MESSAGE_SIZE_BAM_NAME "TotalMessageSizeBAM"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_NEXT_PACKET_NUMBER_TO_BE_SENT_NAME "NextPacketNumberToBeSent"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_TOTAL_NUMBER_OF_PACKETS_NAME "TotalNumberOfPackets"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_TOTAL_NUMBER_OF_PACKETS_EO_MA_NAME "TotalNumberOfPacketsEoMA"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_TOTAL_NUMBER_OF_PACKETS_BAM_NAME "TotalNumberOfPacketsBAM"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_MAXIMUM_NUMBER_OF_PACKETS_NAME "MaximumNumberOfPackets"
#define DURA_MAX_TRANSPORT_PROTOCOL_HEADER_PG_NUMBER_NAME "PGNumber"
#define DURA_MAX_TRANSPORT_PROTOCOL_DATA_SEQUENCE_NUMBER_NAME "SequenceNumber"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_PROTECT_LAMP_STATUS_NAME "ProtectLampStatus"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_AMBER_WARNING_LAMP_STATUS_NAME "AmberWarningLampStatus"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_RED_STOP_LAMP_STATE_NAME "RedStopLampState"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_MALFUNCTION_INDICATOR_LAMP_STATUS_NAME "MalfunctionIndicatorLampStatus"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_PROTECT_LAMP_NAME "FlashProtectLamp"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_AMBER_WARNING_LAMP_NAME "FlashAmberWarningLamp"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_RED_STOP_LAMP_NAME "FlashRedStopLamp"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_FLASH_MALFUNC_INDICATOR_LAMP_NAME "FlashMalfuncIndicatorLamp"
#define DURA_MAX_DM01_ACTIVE_DIAGNOSTICS_DTC1_NAME "DTC1"
#define DURA_MAX_TSC1_31_ENG_OVERRIDE_CTRL_MODE_NAME "EngOverrideCtrlMode"
#define DURA_MAX_TSC1_31_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_NAME "EngRequestedSpeedCtrlConditions"
#define DURA_MAX_TSC1_31_OVERRIDE_CTRL_MODE_PRIORITY_NAME "OverrideCtrlModePriority"
#define DURA_MAX_TSC1_31_ENG_REQUESTED_SPEED_SPEED_LIMIT_NAME "EngRequestedSpeed_SpeedLimit"
#define DURA_MAX_TSC1_31_ENG_REQUESTED_TORQUE_TORQUE_LIMIT_NAME "EngRequestedTorque_TorqueLimit"
#define DURA_MAX_TSC1_31_TSC1_TRANS_RATE_NAME "TSC1TransRate"
#define DURA_MAX_TSC1_31_TSC1_CTRL_PURPOSE_NAME "TSC1CtrlPurpose"
#define DURA_MAX_TSC1_31_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION_NAME "EngRequestedTorqueHighResolution"
#define DURA_MAX_TSC1_31_MESSAGE_COUNTER_NAME "MessageCounter"
#define DURA_MAX_TSC1_31_MESSAGE_CHECKSUM_NAME "MessageChecksum"
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_ENGINE_CHARGE_AIR_COOLER_1_INTAK_NAME "Engine_Charge_Air_Cooler_1_Intak"
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_ENGINE_CHARGE_AIR_COOLER_1_AMBIE_NAME "Engine_Charge_Air_Cooler_1_Ambie"
#define DURA_MAX_CAC1_CHARGE_AIR_COOLER_1_ENGINE_CHARGE_AIR_COOLER_1_EFFIC_NAME "Engine_Charge_Air_Cooler_1_Effic"
#define DURA_MAX_HOURS_ENGINE_HOURS_REVOLUTIONS_ENGINE_TOTAL_HOURS_OF_OPERATION__NAME "Engine_Total_Hours_of_Operation_"
#define DURA_MAX_HOURS_ENGINE_HOURS_REVOLUTIONS_ENGINE_TOTAL_REVOLUTIONS_249__NAME "Engine_Total_Revolutions__249_"
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_ENGINE_TURBOCHARGER_1_TURBINE_OU_NAME "Engine_Turbocharger_1_Turbine_Ou"
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_ENGINE_TURBOCHARGER_2_TURBINE_OU_NAME "Engine_Turbocharger_2_Turbine_Ou"
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_ENGINE_TURBOCHARGER_3_TURBINE_OU_NAME "Engine_Turbocharger_3_Turbine_Ou"
#define DURA_MAX_TCI5_TURBOCHARGER_INFORMATION_5_ENGINE_TURBOCHARGER_4_TURBINE_OU_NAME "Engine_Turbocharger_4_Turbine_Ou"
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_NET_BATTERY_CURRENT_114__NAME "Net_Battery_Current__114_"
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_ALTERNATOR_CURRENT_115__NAME "Alternator_Current__115_"
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_CHARGING_SYSTEM_POTENTIAL_VOLTA_NAME "Charging_System_Potential__Volta"
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_BATTERY_POTENTIAL_POWER_INPUT_1__NAME "Battery_Potential_Power_Input_1_"
#define DURA_MAX_VEP1_VEHICLE_ELECTRICAL_POWER_1_KEYSWITCH_BATTERY_POTENTIAL_158_NAME "Keyswitch_Battery_Potential__158"
#define DURA_MAX_EEC20_ELECTRONIC_ENGINE_CONTROL__ABSOLUTE_ENGINE_LOAD_NAME "Absolute_Engine_Load"
#define DURA_MAX_EASI_ENGINE_AIR_SYSTEM_INFO_ENGINE_INTAKE_MAF_NAME "Engine_Intake_MAF"
#define DURA_MAX_TSC1_03_ENG_OVERRIDE_CTRL_MODE_NAME "EngOverrideCtrlMode"
#define DURA_MAX_TSC1_03_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_NAME "EngRequestedSpeedCtrlConditions"
#define DURA_MAX_TSC1_03_OVERRIDE_CTRL_MODE_PRIORITY_NAME "OverrideCtrlModePriority"
#define DURA_MAX_TSC1_03_ENG_REQUESTED_SPEED_SPEED_LIMIT_NAME "EngRequestedSpeed_SpeedLimit"
#define DURA_MAX_TSC1_03_ENG_REQUESTED_TORQUE_TORQUE_LIMIT_NAME "EngRequestedTorque_TorqueLimit"
#define DURA_MAX_TSC1_03_TSC1_TRANS_RATE_NAME "TSC1TransRate"
#define DURA_MAX_TSC1_03_TSC1_CTRL_PURPOSE_NAME "TSC1CtrlPurpose"
#define DURA_MAX_TSC1_03_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION_NAME "EngRequestedTorqueHighResolution"
#define DURA_MAX_TSC1_03_MESSAGE_COUNTER_NAME "MessageCounter"
#define DURA_MAX_TSC1_03_MESSAGE_CHECKSUM_NAME "MessageChecksum"
#define DURA_MAX_TSC1_0_B_ENG_OVERRIDE_CTRL_MODE_NAME "EngOverrideCtrlMode"
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_SPEED_CTRL_CONDITIONS_NAME "EngRequestedSpeedCtrlConditions"
#define DURA_MAX_TSC1_0_B_OVERRIDE_CTRL_MODE_PRIORITY_NAME "OverrideCtrlModePriority"
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_SPEED_SPEED_LIMIT_NAME "EngRequestedSpeed_SpeedLimit"
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_TORQUE_TORQUE_LIMIT_NAME "EngRequestedTorque_TorqueLimit"
#define DURA_MAX_TSC1_0_B_TSC1_TRANS_RATE_NAME "TSC1TransRate"
#define DURA_MAX_TSC1_0_B_TSC1_CTRL_PURPOSE_NAME "TSC1CtrlPurpose"
#define DURA_MAX_TSC1_0_B_ENG_REQUESTED_TORQUE_HIGH_RESOLUTION_NAME "EngRequestedTorqueHighResolution"
#define DURA_MAX_TSC1_0_B_MESSAGE_COUNTER_NAME "MessageCounter"
#define DURA_MAX_TSC1_0_B_MESSAGE_CHECKSUM_NAME "MessageChecksum"
#define DURA_MAX_DM07_TEST_IDENTIFIER_NAME "TestIdentifier"
#define DURA_MAX_DM07_SPN1_NAME "SPN1"
#define DURA_MAX_DM07_FAILURE_MODE_IDENTIFIER1_NAME "FailureModeIdentifier1"
#define DURA_MAX_DM07_SPN1_HIGH_NAME "SPN1High"
#define DURA_MAX_DM08_TEST_IDENTIFIER_NAME "TestIdentifier"
#define DURA_MAX_DM08_TEST_TYPE_NAME "TestType"
#define DURA_MAX_DM08_TEST_VALUE_NAME "TestValue"
#define DURA_MAX_DM08_TEST_LIMIT_MAXIMUM_NAME "TestLimitMaximum"
#define DURA_MAX_DM08_TEST_LIMIT_MINIMUM_NAME "TestLimitMinimum"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_TORQUE_MODE_NAME "RetarderTorqueMode"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_BRAKE_ASSIST_SWITCH_NAME "RetarderEnableBrakeAssistSwitch"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ENABLE_SHIFT_ASSIST_SWITCH_NAME "RetarderEnableShiftAssistSwitch"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_ACTUAL_RETARDER_PERCENT_TORQUE_NAME "ActualRetarderPercentTorque"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_INTENDED_RETARDER_PERCENT_TORQUE_NAME "IntendedRetarderPercentTorque"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_ENG_COOLANT_LOAD_INCREASE_NAME "EngCoolantLoadIncrease"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_REQUESTING_BRAKE_LIGHT_NAME "RetarderRequestingBrakeLight"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_LIMIT_SWITCH_NAME "RetarderRoadSpeedLimitSwitch"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_ROAD_SPEED_EXCEEDED_STATUS_NAME "RetarderRoadSpeedExceededStatus"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_SRC_ADDRSS_OF_CNTRLLNG_DVC_FR_RTRDR_CTR_NAME "SrcAddrssOfCntrllngDvcFrRtrdrCtr"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_DRVRS_DEMAND_RETARDER_PERCENT_TORQUE_NAME "DrvrsDemandRetarderPercentTorque"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_RETARDER_SELECTION_NONENGINE_NAME "RetarderSelectionNonengine"
#define DURA_MAX_ERC1_ELECTRONIC_RETARDER_CNTRL_ACTL_MX_AVLBL_RETARDER_PERCENT_TORQUE_NAME "ActlMxAvlblRetarderPercentTorque"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_DRIVELINE_ENGAGED_NAME "TransDrivelineEngaged"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TORQUE_CONVERTER_LOCKUP_ENGAGED_NAME "TrnsTorqueConverterLockupEngaged"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_SHIFT_IN_PROCESS_NAME "TransShiftInProcess"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRNS_TRQ_CNVRTR_LCKP_TRNSTN_IN_PROCESS_NAME "TrnsTrqCnvrtrLckpTrnstnInProcess"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_OUTPUT_SHAFT_SPEED_NAME "TransOutputShaftSpeed"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_PERCENT_CLUTCH_SLIP_NAME "PercentClutchSlip"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_ENG_MOMENTARY_OVERSPEED_ENABLE_NAME "EngMomentaryOverspeedEnable"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_PROGRESSIVE_SHIFT_DISABLE_NAME "ProgressiveShiftDisable"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_MOMENTARY_ENG_MAX_POWER_ENABLE_NAME "MomentaryEngMaxPowerEnable"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_TRANS_INPUT_SHAFT_SPEED_NAME "TransInputShaftSpeed"
#define DURA_MAX_ETC1_ELECTRONIC_TRANS_CNTRL_1_SRC_ADDRSS_OF_CNTRLLNG_DVC_FR_TRNS_CTRL_NAME "SrcAddrssOfCntrllngDvcFrTrnsCtrl"
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_TRANS_SELECTED_GEAR_NAME "TransSelectedGear"
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_TRANS_ACTUAL_GEAR_RATIO_NAME "TransActualGearRatio"
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_TRANS_CURRENT_GEAR_NAME "TransCurrentGear"
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_TRANS_REQUESTED_RANGE_NAME "TransRequestedRange"
#define DURA_MAX_ETC2_ELECTRONIC_TRANS_CNTRL_2_TRANS_CURRENT_RANGE_NAME "TransCurrentRange"
#define DURA_MAX_RQST_00_5_E_PARAMETER_GROUP_NUMBER_NAME "ParameterGroupNumber"
#define DURA_MAX_RQST_00_21_PARAMETER_GROUP_NUMBER_NAME "ParameterGroupNumber"
#define DURA_MAX_RQST_GLOBAL_5_E_PARAMETER_GROUP_NUMBER_NAME "ParameterGroupNumber"
#define DURA_MAX_RQST_GLOBAL_03_PARAMETER_GROUP_NUMBER_NAME "ParameterGroupNumber"
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_TRANSFER_CASE_STATUS_NAME "TransferCaseStatus"
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_DIR_STATUS_NAME "DirStatus"
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_ACTUAL_GEAR_RATIO_NAME "ActualGearRatio"
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_MESSAGE_COUNTER_NAME "MessageCounter"
#define DURA_MAX_TCI_TRANSFER_CASE_INFORMATION_MESSAGE_CHECKSUM_NAME "MessageChecksum"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_CLUTCH_PRESS_NAME "ClutchPress"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_NAME "TransOilLevel1"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_FILTER_DIFF_PRESS_NAME "TransFilterDiffPress"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_PRESS_NAME "TransOilPress"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_TEMP1_NAME "TransOilTemp1"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_HIGH_LOW_NAME "TransOilLevel1High_Low"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_COUNTDOWN_TIMER_NAME "TransOilLevel1CountdownTimer"
#define DURA_MAX_TRF1_TRANSMISSION_FLUIDS_1_TRANS_OIL_LEVEL1_MEASUREMENT_STATUS_NAME "TransOilLevel1MeasurementStatus"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_MAX_VEHICLE_SPEED_LIMIT_NAME "MaxVehicleSpeedLimit"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CRUISE_CTRL_HIGH_SET_LIMIT_SPEED_NAME "CruiseCtrlHighSetLimitSpeed"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CRUISE_CTRL_LOW_SET_LIMIT_SPEED_NAME "CruiseCtrlLowSetLimitSpeed"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_MAX_VEHICLE_SPEED_LIMIT6808_NAME "MaxVehicleSpeedLimit6808"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_SYS_LOW_SET_LMT_SPD_NAME "CtrlSysLowSetLmtSpd"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_DIS_CMD_SUPPORT_NAME "CtrlDisCmdSupport"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_RESUME_CMD_SUPPORT_NAME "CtrlResumeCmdSupport"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_PAUSE_CMD_SUPPORT_NAME "CtrlPauseCmdSupport"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_CTRL_SET_CMD_SUPPORT_NAME "CtrlSetCmdSupport"
#define DURA_MAX_CCSS_CRUISE_CONTROL_VEHICLE_SPD_POWERTRAIN_ADAPTIVE_CC_TYPE_NAME "PowertrainAdaptiveCCType"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_TWO_SPEED_AXLE_SWITCH_NAME "TwoSpeedAxleSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARKING_BRAKE_SWITCH_NAME "ParkingBrakeSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_PAUSE_SWITCH_NAME "CruiseCtrlPauseSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PARK_BRAKE_RELEASE_INHIBIT_RQ_NAME "ParkBrakeReleaseInhibitRq"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_WHEEL_BASED_VEHICLE_SPEED_NAME "WheelBasedVehicleSpeed"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACTIVE_NAME "CruiseCtrlActive"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ENABLE_SWITCH_NAME "CruiseCtrlEnableSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_BRAKE_SWITCH_NAME "BrakeSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CLUTCH_SWITCH_NAME "ClutchSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_SET_SWITCH_NAME "CruiseCtrlSetSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_COAST_SWITCH_NAME "CruiseCtrlCoastSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_RESUME_SWITCH_NAME "CruiseCtrlResumeSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_ACCELERATE_SWITCH_NAME "CruiseCtrlAccelerateSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_SET_SPEED_NAME "CruiseCtrlSetSpeed"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_PTO_GOVERNOR_STATE_NAME "PTOGovernorState"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_CRUISE_CTRL_STATES_NAME "CruiseCtrlStates"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_INCREMENT_SWITCH_NAME "EngIdleIncrementSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_IDLE_DECREMENT_SWITCH_NAME "EngIdleDecrementSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_TEST_MODE_SWITCH_NAME "EngTestModeSwitch"
#define DURA_MAX_CCVS1_CRUISE_CONTROL_VEH_SPD_ENG_SHUTDOWN_OVERRIDE_SWITCH_NAME "EngShutdownOverrideSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_ENG_CTRL_ACTIVE_NAME "ASREngCtrlActive"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_BRAKE_CTRL_ACTIVE_NAME "ASRBrakeCtrlActive"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ANTI_LOCK_BRAKING_ACTIVE_NAME "AntiLockBrakingActive"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_BRAKE_SWITCH_NAME "EBSBrakeSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_BRAKE_PEDAL_POS_NAME "BrakePedalPos"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_OFFROAD_SWITCH_NAME "ABSOffroadSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_OFFROAD_SWITCH_NAME "ASROffroadSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ASR_HILL_HOLDER_SWITCH_NAME "ASRHillHolderSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRACTION_CTRL_OVERRIDE_SWITCH_NAME "TractionCtrlOverrideSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ACCEL_INTERLOCK_SWITCH_NAME "AccelInterlockSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_DERATE_SWITCH_NAME "EngDerateSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_AUX_SHUTDOWN_SWITCH_NAME "EngAuxShutdownSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_REMOTE_ACCEL_ENABLE_SWITCH_NAME "RemoteAccelEnableSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ENG_RETARDER_SELECTION_NAME "EngRetarderSelection"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_FULLY_OPERATIONAL_NAME "ABSFullyOperational"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_EBS_RED_WARNING_SIGNAL_NAME "EBSRedWarningSignal"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ABS_EBS_AMBER_WARNING_SIGNAL_NAME "ABS_EBSAmberWarningSignal"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_ATC_ASR_INFORMATION_SIGNAL_NAME "ATC_ASRInformationSignal"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_SRC_ADDRSS_OF_CNTRLLNG_DVC_FR_BRKE_CTRL_NAME "SrcAddrssOfCntrllngDvcFrBrkeCtrl"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_RAILROAD_MODE_SW_NAME "RailroadModeSw"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_HALT_BRAKE_SWITCH_NAME "HaltBrakeSwitch"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRAILER_ABS_STATUS_NAME "TrailerABSStatus"
#define DURA_MAX_EBC1_ELECTRONIC_BRAKE_CNTRL_TRCTR_MNTD_TRAILER_ABS_WARNING_SIGNAL_NAME "TrctrMntdTrailerABSWarningSignal"
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_HAS_SHUTDOWN_ENG_NAME "EngIdleShutdownHasShutdownEng"
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_DRIVER_ALERT_MODE_NAME "EngIdleShutdownDriverAlertMode"
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_OVERRIDE_NAME "EngIdleShutdownTimerOverride"
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_STATE_NAME "EngIdleShutdownTimerState"
#define DURA_MAX_SHUTDN_ENG_IDLE_SHUTDOWN_TIMER_FUNCTION_NAME "EngIdleShutdownTimerFunction"
#define DURA_MAX_SHUTDN_A_C_HIGH_PRESS_FAN_SWITCH_NAME "A_CHighPressFanSwitch"
#define DURA_MAX_SHUTDN_REFRIGERANT_LOW_PRESS_SWITCH_NAME "RefrigerantLowPressSwitch"
#define DURA_MAX_SHUTDN_REFRIGERANT_HIGH_PRESS_SWITCH_NAME "RefrigerantHighPressSwitch"
#define DURA_MAX_SHUTDN_ENG_WAIT_TO_START_LAMP_NAME "EngWaitToStartLamp"
#define DURA_MAX_SHUTDN_ENG_PRTECTION_SYSTEM_HAS_SHUTDOWN_ENG_NAME "EngPrtectionSystemHasShutdownEng"
#define DURA_MAX_SHUTDN_ENG_PRTCTN_SYSTM_APPRACHING_SHUTDOWN_NAME "EngPrtctnSystmApprachingShutdown"
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_OVERRIDE_NAME "EngProtectionSystemTimerOverride"
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_TIMER_STATE_NAME "EngProtectionSystemTimerState"
#define DURA_MAX_SHUTDN_ENG_PROTECTION_SYSTEM_CONFIG_NAME "EngProtectionSystemConfig"
#define DURA_MAX_SHUTDN_ENG_ALARM_ACKNOWLEDGE_NAME "EngAlarmAcknowledge"
#define DURA_MAX_SHUTDN_ENG_ALARM_OUTPUT_CMD_STATUS_NAME "EngAlarmOutputCmdStatus"
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_CMD_STATUS_NAME "EngAirShutoffCmdStatus"
#define DURA_MAX_SHUTDN_ENG_OVERSPEED_TEST_NAME "EngOverspeedTest"
#define DURA_MAX_SHUTDN_ENG_AIR_SHUTOFF_STATUS_NAME "EngAirShutoffStatus"
#define DURA_MAX_SHUTDN_PTO_SHUTDOWN_HAS_SHUTDOWN_ENG_NAME "PTOShutdownHasShutdownEng"
#define DURA_MAX_SHUTDN_CLNT_LVL_ENG_PRTCTION_SHUTDOWN_STATUS_NAME "ClntLvlEngPrtctionShutdownStatus"
#define DURA_MAX_SHUTDN_ENG_OIL_PRESS_SW_NAME "EngOilPressSw"

/**
 * Signals in message EEC5_Electronic_Engine_Control_5.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_eec5_electronic_engine_control_5_t {
    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_turbocharger_1_calculated;

    /**
     * Range: 0..64255 (0..160.6375 %)
     * Scale: 0.0025
     * Offset: 0
     */
    uint16_t commanded_vgt_position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_variable_geometry_turboch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_fuel_control_control_mode;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_vgt_control_mode;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t actual_vgt_position;
};

/**
 * Signals in message EEC9_Electronic_Engine_Control_9.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_eec9_electronic_engine_control_9_t {
    /**
     * Range: 0..64255 (0..160.6375 %)
     * Scale: 0.0025
     * Offset: 0
     */
    uint16_t engine_exhaust_gas_recirculation;

    /**
     * Range: 0..64255 (0..250.996 Mpa)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t commanded_fuel_rail_pressure;

    /**
     * Range: 0..64255 (0..250.996 Mpa)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t commanded_engine_fuel_injection_;
};

/**
 * Signals in message EBCC_Engine_Exhaust_Brake_Cont.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_ebcc_engine_exhaust_brake_cont_t {
    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t actual_boost_pressure;

    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t desired_boost_pressure;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t engine_exhaust_brake_actuator_co;

    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t engine_turbocharger_2_turbine_ou;

    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t desired_engine_turbocharger_2_tu;
};

/**
 * Signals in message ET3_Engine_Temperature_3.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_et3_engine_temperature_3_t {
    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_intake_manifold_1_air_tem;

    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_coolant_temperature_high;

    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_intake_valve_actuation_sy;

    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_cac_outlet_temperature;
};

/**
 * Signals in message DM21_Diagnostic_Readiness_2.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_dm21_diagnostic_readiness_2_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t engine_run_time_with_mil_on;
};

/**
 * Signals in message DM26_Diagnostic_Readiness_3.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_dm26_diagnostic_readiness_3_t {
    /**
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t time_since_engine_start;
};

/**
 * Signals in message IC1_Intake_Exhaust_Cond_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_ic1_intake_exhaust_cond_1_t {
    /**
     * Range: 0..250 (0..125 kPa)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t aft1_dpf_in_press;

    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t eng_intake_manifold1_press;

    /**
     * Range: 0..250 (-40..210 C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t eng_intake_manifold1_temp;

    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t eng_air_intake_press;

    /**
     * Range: 0..250 (0..12.5 kPa)
     * Scale: 0.05
     * Offset: 0
     */
    uint8_t eng_air_filter1_diff_press;

    /**
     * Range: 0..64255 (-273..1734.96875 C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t eng_exhaust_gas_temp;

    /**
     * Range: 0..250 (0..125 kPa)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t eng_coolant_filter_diff_press;
};

/**
 * Signals in message AMB_Ambient_Conditions.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_amb_ambient_conditions_t {
    /**
     * Range: 0..250 (0..125 kPa)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t barometric_pressure_barometric_pr;

    /**
     * Range: 0..64255 (-273..1734.96875 C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t cab_interior_temp;

    /**
     * Range: 0..64255 (-273..1734.96875 C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t ambient_air_temperature;

    /**
     * Range: 0..250 (-40..210 C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t engine_air_intake_temperature;

    /**
     * Range: 0..64255 (-273..1734.96875 C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t road_surface_temp;
};

/**
 * Signals in message EEC1_Electronic_Engine_Control_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_eec1_electronic_engine_control_1_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_torque_mode;

    /**
     * Range: 0..7 (0..0.875 %)
     * Scale: 0.125
     * Offset: 0
     */
    uint8_t actl_eng_prcnt_torque_high_resolution;

    /**
     * Range: 125..250 (0..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t drivers_demand_engine_prcnt_torq;

    /**
     * Range: 125..250 (0..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t actual_engine_percent_torque;

    /**
     * Range: 0..64255 (0..8031.875 rpm)
     * Scale: 0.125
     * Offset: 0
     */
    uint16_t engine_speed;

    /**
     * Range: 0..253 (0..253 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t src_addrss_of_cntrllng_dvc_for_eng_ctrl;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_starter_mode;

    /**
     * Range: 0..250 (-125..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t engine_demand_percent_torque;
};

/**
 * Signals in message EEC2_Electronic_Engine_Control_2.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_eec2_electronic_engine_control_2_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accel_pedal1_low_idle_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accel_pedal_kickdown_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t road_speed_limit_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accel_pedal2_low_idle_switch;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t accel_pedal_pos1;

    /**
     * Range: 0..125 (0..125 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_percent_load_at_current_speed;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t remote_accel_pedal_pos;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t accel_pedal_pos2;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vhcle_acceleration_rate_limit_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mmntary_eng_max_power_enable_feedback;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dpf_thermal_management_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t scr_thermal_management_active;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t actl_max_available_eng_percent_torque;

    /**
     * Range: 0..250 (-125..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t est_pumping_percent_torque;
};

/**
 * Signals in message EEC3_Electronic_Engine_Control_3.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_eec3_electronic_engine_control_3_t {
    /**
     * Range: 0..250 (-125..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t nominal_friction_percent_torque;

    /**
     * Range: 0..64255 (0..8031.875 rpm)
     * Scale: 0.125
     * Offset: 0
     */
    uint16_t engines_desired_operating_speed;

    /**
     * Range: 0..250 (0..250 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engns_dsrd_oprtng_spd_asymmtry_adjstm;

    /**
     * Range: 125..250 (0..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t est_eng_prsitic_losses_percent_torque;

    /**
     * Range: 0..64255 (0..12851 kg/h)
     * Scale: 0.2
     * Offset: 0
     */
    uint16_t aft1_exh_gas_mfr;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aft1_in_dew_point;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aft1_exh_dew_point;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aft2_in_dew_point;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aft2_exh_dew_point;
};

/**
 * Signals in message EFL_P1_Eng_Fluid_Level_Press_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_efl_p1_eng_fluid_level_press_1_t {
    /**
     * Range: 0..250 (0..1000 kPa)
     * Scale: 4
     * Offset: 0
     */
    uint8_t eng_fuel_delivery_press;

    /**
     * Range: 0..250 (0..12.5 kPa)
     * Scale: 0.05
     * Offset: 0
     */
    uint8_t eng_ex_crankcase_blowby_press;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t eng_oil_level;

    /**
     * Range: 0..250 (0..1000 kPa)
     * Scale: 4
     * Offset: 0
     */
    uint8_t eng_oil_press;

    /**
     * Range: 0..64255 (-250..251.99 kPa)
     * Scale: 0.0078125
     * Offset: -250
     */
    uint16_t eng_crankcase_press;

    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t eng_coolant_press;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t eng_coolant_level;
};

/**
 * Signals in message EFL_P2_Eng_Fluid_Level_Press_2.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_efl_p2_eng_fluid_level_press_2_t {
    /**
     * Range: 0..64255 (0..250.996 MPa)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t eng_injection_ctrl_press;

    /**
     * Range: 0..64255 (0..250.996 MPa)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t eng_injector_metering_rail1_press;

    /**
     * Range: 0..64255 (0..250.996 MPa)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t eng_injector_timing_rail1_press;

    /**
     * Range: 0..64255 (0..250.996 MPa)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t eng_injector_metering_rail2_press;
};

/**
 * Signals in message ET1_Engine_Temperature_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_et1_engine_temperature_1_t {
    /**
     * Range: 0..250 (-40..210 C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t eng_coolant_temp;

    /**
     * Range: 0..250 (-40..210 C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t eng_fuel_temp1;

    /**
     * Range: 0..64255 (-273..1734.96875 C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t eng_oil_temp1;

    /**
     * Range: 0..64255 (-273..1734.96875 C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t eng_turbo_oil_temp;

    /**
     * Range: 0..250 (-40..210 C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t eng_intercooler_temp;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t eng_intercooler_thermostat_opening;
};

/**
 * Signals in message LFE1_Fuel_Economy_Liquid_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_lfe1_fuel_economy_liquid_1_t {
    /**
     * Range: 0..64255 (0..3212.75 l/h)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t eng_fuel_rate;

    /**
     * Range: 0..64255 (0..125.49805 km/L)
     * Scale: 0.00195312
     * Offset: 0
     */
    uint16_t eng_instantaneous_fuel_economy;

    /**
     * Range: 0..64255 (0..125.49805 km/L)
     * Scale: 0.00195312
     * Offset: 0
     */
    uint16_t eng_average_fuel_economy;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t eng_throttle_valve1_pos;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t eng_throttle_valve2_pos;
};

/**
 * Signals in message TransportProtocol_Header.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_transport_protocol_header_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_byte;

    /**
     * Range: 0..64255 (0..64255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t total_message_size_eo_ma;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t connection_abort_reason;

    /**
     * Range: 0..64255 (0..64255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t total_message_size;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t number_of_packets_that_can_be_sent;

    /**
     * Range: 0..64255 (0..64255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t total_message_size_bam;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t next_packet_number_to_be_sent;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_number_of_packets;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_number_of_packets_eo_ma;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_number_of_packets_bam;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t maximum_number_of_packets;

    /**
     * Range: 0..16777200 (0..16777200 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t pg_number;
};

/**
 * Signals in message TransportProtocol_Data.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_transport_protocol_data_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sequence_number;
};

/**
 * Signals in message DM01_Active_Diagnostics.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_dm01_active_diagnostics_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t protect_lamp_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t amber_warning_lamp_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t red_stop_lamp_state;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t malfunction_indicator_lamp_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flash_protect_lamp;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flash_amber_warning_lamp;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flash_red_stop_lamp;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t flash_malfunc_indicator_lamp;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t dtc1;
};

/**
 * Signals in message TSC1_31.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_tsc1_31_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_override_ctrl_mode;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_requested_speed_ctrl_conditions;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t override_ctrl_mode_priority;

    /**
     * Range: 0..64255 (0..8031.875 rpm)
     * Scale: 0.125
     * Offset: 0
     */
    uint16_t eng_requested_speed_speed_limit;

    /**
     * Range: 0..250 (-125..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t eng_requested_torque_torque_limit;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsc1_trans_rate;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsc1_ctrl_purpose;

    /**
     * Range: 0..7 (0..0.875 %)
     * Scale: 0.125
     * Offset: 0
     */
    uint8_t eng_requested_torque_high_resolution;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_counter;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_checksum;
};

/**
 * Signals in message CAC1_Charge_Air_Cooler_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_cac1_charge_air_cooler_1_t {
    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_charge_air_cooler_1_intak;

    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_charge_air_cooler_1_ambie;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t engine_charge_air_cooler_1_effic;
};

/**
 * Signals in message HOURS_Engine_Hours_Revolutions.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_hours_engine_hours_revolutions_t {
    /**
     * Range: 0..4211081215 (0..210554060.75 hr)
     * Scale: 0.05
     * Offset: 0
     */
    uint32_t engine_total_hours_of_operation_;

    /**
     * Range: 0..4211081215 (0..4211081215000 r)
     * Scale: 1000
     * Offset: 0
     */
    uint32_t engine_total_revolutions_249_;
};

/**
 * Signals in message TCI5_Turbocharger_Information_5.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_tci5_turbocharger_information_5_t {
    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_turbocharger_1_turbine_ou;

    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_turbocharger_2_turbine_ou;

    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_turbocharger_3_turbine_ou;

    /**
     * Range: 0..64255 (-273..1734.96875 deg C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t engine_turbocharger_4_turbine_ou;
};

/**
 * Signals in message VEP1_Vehicle_Electrical_Power_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_vep1_vehicle_electrical_power_1_t {
    /**
     * Range: 0..250 (-125..125 A)
     * Scale: 1
     * Offset: -125
     */
    uint8_t net_battery_current_114_;

    /**
     * Range: 0..250 (0..250 A)
     * Scale: 1
     * Offset: 0
     */
    uint8_t alternator_current_115_;

    /**
     * Range: 0..64255 (0..3212.75 V)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t charging_system_potential_volta;

    /**
     * Range: 0..64255 (0..3212.75 V)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t battery_potential_power_input_1_;

    /**
     * Range: 0..64255 (0..3212.75 V)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t keyswitch_battery_potential_158;
};

/**
 * Signals in message EEC20_Electronic_Engine_Control_.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_eec20_electronic_engine_control__t {
    /**
     * Range: 0..65535 (0..1638.375 -)
     * Scale: 0.025
     * Offset: 0
     */
    uint16_t absolute_engine_load;
};

/**
 * Signals in message EASI_Engine_Air_System_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_easi_engine_air_system_info_t {
    /**
     * Range: 0..65535 (0..63.99902 kg/s)
     * Scale: 0.000976562
     * Offset: 0
     */
    uint16_t engine_intake_maf;
};

/**
 * Signals in message TSC1_03.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_tsc1_03_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_override_ctrl_mode;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_requested_speed_ctrl_conditions;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t override_ctrl_mode_priority;

    /**
     * Range: 0..64255 (0..8031.875 rpm)
     * Scale: 0.125
     * Offset: 0
     */
    uint16_t eng_requested_speed_speed_limit;

    /**
     * Range: 0..250 (-125..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t eng_requested_torque_torque_limit;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsc1_trans_rate;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsc1_ctrl_purpose;

    /**
     * Range: 0..7 (0..0.875 %)
     * Scale: 0.125
     * Offset: 0
     */
    uint8_t eng_requested_torque_high_resolution;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_counter;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_checksum;
};

/**
 * Signals in message TSC1_0B.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_tsc1_0_b_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_override_ctrl_mode;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_requested_speed_ctrl_conditions;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t override_ctrl_mode_priority;

    /**
     * Range: 0..64255 (0..8031.875 rpm)
     * Scale: 0.125
     * Offset: 0
     */
    uint16_t eng_requested_speed_speed_limit;

    /**
     * Range: 0..250 (-125..125 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t eng_requested_torque_torque_limit;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsc1_trans_rate;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsc1_ctrl_purpose;

    /**
     * Range: 0..7 (0..0.875 %)
     * Scale: 0.125
     * Offset: 0
     */
    uint8_t eng_requested_torque_high_resolution;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_counter;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_checksum;
};

/**
 * Signals in message DM07.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_dm07_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_identifier;

    /**
     * Range: 0..524287 (0..524287 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t spn1;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t failure_mode_identifier1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t spn1_high;
};

/**
 * Signals in message DM08.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_dm08_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_identifier;

    /**
     * Range: 0..250 (0..250 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t test_value;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t test_limit_maximum;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t test_limit_minimum;
};

/**
 * Signals in message ERC1_Electronic_Retarder_Cntrl.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_erc1_electronic_retarder_cntrl_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retarder_torque_mode;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retarder_enable_brake_assist_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retarder_enable_shift_assist_switch;

    /**
     * Range: 0..125 (-125..0 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t actual_retarder_percent_torque;

    /**
     * Range: 0..125 (-125..0 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t intended_retarder_percent_torque;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_coolant_load_increase;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retarder_requesting_brake_light;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retarder_road_speed_limit_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retarder_road_speed_exceeded_status;

    /**
     * Range: 0..253 (0..253 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t src_addrss_of_cntrllng_dvc_fr_rtrdr_ctr;

    /**
     * Range: 0..125 (-125..0 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t drvrs_demand_retarder_percent_torque;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t retarder_selection_nonengine;

    /**
     * Range: 0..125 (-125..0 %)
     * Scale: 1
     * Offset: -125
     */
    uint8_t actl_mx_avlbl_retarder_percent_torque;
};

/**
 * Signals in message ETC1_Electronic_Trans_Cntrl_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_etc1_electronic_trans_cntrl_1_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_driveline_engaged;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trns_torque_converter_lockup_engaged;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_shift_in_process;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trns_trq_cnvrtr_lckp_trnstn_in_process;

    /**
     * Range: 0..64255 (0..8031.875 rpm)
     * Scale: 0.125
     * Offset: 0
     */
    uint16_t trans_output_shaft_speed;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t percent_clutch_slip;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_momentary_overspeed_enable;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t progressive_shift_disable;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t momentary_eng_max_power_enable;

    /**
     * Range: 0..64255 (0..8031.875 rpm)
     * Scale: 0.125
     * Offset: 0
     */
    uint16_t trans_input_shaft_speed;

    /**
     * Range: 0..253 (0..253 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t src_addrss_of_cntrllng_dvc_fr_trns_ctrl;
};

/**
 * Signals in message ETC2_Electronic_Trans_Cntrl_2.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_etc2_electronic_trans_cntrl_2_t {
    /**
     * Range: 0..250 (-125..125 -)
     * Scale: 1
     * Offset: -125
     */
    uint8_t trans_selected_gear;

    /**
     * Range: 0..64255 (0..64.255 -)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t trans_actual_gear_ratio;

    /**
     * Range: 0..250 (-125..125 -)
     * Scale: 1
     * Offset: -125
     */
    uint8_t trans_current_gear;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trans_requested_range;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trans_current_range;
};

/**
 * Signals in message RQST_00_5E.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_rqst_00_5_e_t {
    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t parameter_group_number;
};

/**
 * Signals in message RQST_00_21.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_rqst_00_21_t {
    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t parameter_group_number;
};

/**
 * Signals in message RQST_Global_5E.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_rqst_global_5_e_t {
    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t parameter_group_number;
};

/**
 * Signals in message RQST_Global_03.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_rqst_global_03_t {
    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t parameter_group_number;
};

/**
 * Signals in message TCI_Transfer_Case_Information.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_tci_transfer_case_information_t {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t transfer_case_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dir_status;

    /**
     * Range: 0..64255 (0..642.55 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t actual_gear_ratio;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_counter;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t message_checksum;
};

/**
 * Signals in message TRF1_Transmission_Fluids_1.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_trf1_transmission_fluids_1_t {
    /**
     * Range: 0..250 (0..4000 kPa)
     * Scale: 16
     * Offset: 0
     */
    uint8_t clutch_press;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t trans_oil_level1;

    /**
     * Range: 0..250 (0..500 kPa)
     * Scale: 2
     * Offset: 0
     */
    uint8_t trans_filter_diff_press;

    /**
     * Range: 0..250 (0..4000 kPa)
     * Scale: 16
     * Offset: 0
     */
    uint8_t trans_oil_press;

    /**
     * Range: 0..64255 (-273..1734.96875 C)
     * Scale: 0.03125
     * Offset: -273
     */
    uint16_t trans_oil_temp1;

    /**
     * Range: 0..250 (-62.5..62.5 l)
     * Scale: 0.5
     * Offset: -62.5
     */
    uint8_t trans_oil_level1_high_low;

    /**
     * Range: 0..13 (0..13 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_oil_level1_countdown_timer;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trans_oil_level1_measurement_status;
};

/**
 * Signals in message CCSS_Cruise_Control_Vehicle_Spd.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_ccss_cruise_control_vehicle_spd_t {
    /**
     * Range: 0..250 (0..250 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t max_vehicle_speed_limit;

    /**
     * Range: 0..250 (0..250 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_high_set_limit_speed;

    /**
     * Range: 0..250 (0..250 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_low_set_limit_speed;

    /**
     * Range: 0..64255 (0..250.996 km/h)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t max_vehicle_speed_limit6808;

    /**
     * Range: 0..250 (0..250 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrl_sys_low_set_lmt_spd;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrl_dis_cmd_support;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrl_resume_cmd_support;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrl_pause_cmd_support;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrl_set_cmd_support;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t powertrain_adaptive_cc_type;
};

/**
 * Signals in message CCVS1__Cruise_Control_VehSpd.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_ccvs1_cruise_control_veh_spd_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t two_speed_axle_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t parking_brake_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_pause_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t park_brake_release_inhibit_rq;

    /**
     * Range: 0..64255 (0..250.996 km/h)
     * Scale: 0.00390625
     * Offset: 0
     */
    uint16_t wheel_based_vehicle_speed;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_enable_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clutch_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_set_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_coast_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_resume_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_accelerate_switch;

    /**
     * Range: 0..250 (0..250 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_set_speed;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pto_governor_state;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_ctrl_states;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_idle_increment_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_idle_decrement_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_test_mode_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_shutdown_override_switch;
};

/**
 * Signals in message EBC1_Electronic_Brake_Cntrl.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_ebc1_electronic_brake_cntrl_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t asr_eng_ctrl_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t asr_brake_ctrl_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t anti_lock_braking_active;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_brake_switch;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t brake_pedal_pos;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t abs_offroad_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t asr_offroad_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t asr_hill_holder_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t traction_ctrl_override_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t accel_interlock_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_derate_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_aux_shutdown_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t remote_accel_enable_switch;

    /**
     * Range: 0..250 (0..100 %)
     * Scale: 0.4
     * Offset: 0
     */
    uint8_t eng_retarder_selection;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t abs_fully_operational;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_red_warning_signal;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t abs_ebs_amber_warning_signal;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t atc_asr_information_signal;

    /**
     * Range: 0..253 (0..253 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t src_addrss_of_cntrllng_dvc_fr_brke_ctrl;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t railroad_mode_sw;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t halt_brake_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trailer_abs_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t trctr_mntd_trailer_abs_warning_signal;
};

/**
 * Signals in message SHUTDN.
 *
 * All signal values are as on the CAN bus.
 */
struct dura_max_shutdn_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_idle_shutdown_has_shutdown_eng;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_idle_shutdown_driver_alert_mode;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_idle_shutdown_timer_override;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_idle_shutdown_timer_state;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_idle_shutdown_timer_function;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t a_c_high_press_fan_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t refrigerant_low_press_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t refrigerant_high_press_switch;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_wait_to_start_lamp;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_prtection_system_has_shutdown_eng;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_prtctn_systm_appraching_shutdown;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_protection_system_timer_override;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_protection_system_timer_state;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_protection_system_config;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_alarm_acknowledge;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_alarm_output_cmd_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_air_shutoff_cmd_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_overspeed_test;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_air_shutoff_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pto_shutdown_has_shutdown_eng;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clnt_lvl_eng_prtction_shutdown_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eng_oil_press_sw;
};

/**
 * Pack message EEC5_Electronic_Engine_Control_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_eec5_electronic_engine_control_5_pack(
    uint8_t *dst_p,
    const struct dura_max_eec5_electronic_engine_control_5_t *src_p,
    size_t size);

/**
 * Unpack message EEC5_Electronic_Engine_Control_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_eec5_electronic_engine_control_5_unpack(
    struct dura_max_eec5_electronic_engine_control_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EEC5_Electronic_Engine_Control_5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_eec5_electronic_engine_control_5_init(struct dura_max_eec5_electronic_engine_control_5_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec5_electronic_engine_control_5_engine_turbocharger_1_calculated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec5_electronic_engine_control_5_engine_turbocharger_1_calculated_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec5_electronic_engine_control_5_engine_turbocharger_1_calculated_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec5_electronic_engine_control_5_commanded_vgt_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec5_electronic_engine_control_5_commanded_vgt_position_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec5_electronic_engine_control_5_commanded_vgt_position_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec5_electronic_engine_control_5_engine_variable_geometry_turboch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec5_electronic_engine_control_5_engine_variable_geometry_turboch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec5_electronic_engine_control_5_engine_variable_geometry_turboch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec5_electronic_engine_control_5_engine_fuel_control_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec5_electronic_engine_control_5_engine_fuel_control_control_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec5_electronic_engine_control_5_engine_fuel_control_control_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec5_electronic_engine_control_5_engine_vgt_control_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec5_electronic_engine_control_5_engine_vgt_control_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec5_electronic_engine_control_5_engine_vgt_control_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec5_electronic_engine_control_5_actual_vgt_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec5_electronic_engine_control_5_actual_vgt_position_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec5_electronic_engine_control_5_actual_vgt_position_is_in_range(uint8_t value);

/**
 * Pack message EEC9_Electronic_Engine_Control_9.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_eec9_electronic_engine_control_9_pack(
    uint8_t *dst_p,
    const struct dura_max_eec9_electronic_engine_control_9_t *src_p,
    size_t size);

/**
 * Unpack message EEC9_Electronic_Engine_Control_9.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_eec9_electronic_engine_control_9_unpack(
    struct dura_max_eec9_electronic_engine_control_9_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EEC9_Electronic_Engine_Control_9.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_eec9_electronic_engine_control_9_init(struct dura_max_eec9_electronic_engine_control_9_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec9_electronic_engine_control_9_engine_exhaust_gas_recirculation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec9_electronic_engine_control_9_engine_exhaust_gas_recirculation_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec9_electronic_engine_control_9_engine_exhaust_gas_recirculation_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec9_electronic_engine_control_9_commanded_fuel_rail_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec9_electronic_engine_control_9_commanded_fuel_rail_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec9_electronic_engine_control_9_commanded_fuel_rail_pressure_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec9_electronic_engine_control_9_commanded_engine_fuel_injection__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec9_electronic_engine_control_9_commanded_engine_fuel_injection__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec9_electronic_engine_control_9_commanded_engine_fuel_injection__is_in_range(uint16_t value);

/**
 * Pack message EBCC_Engine_Exhaust_Brake_Cont.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_ebcc_engine_exhaust_brake_cont_pack(
    uint8_t *dst_p,
    const struct dura_max_ebcc_engine_exhaust_brake_cont_t *src_p,
    size_t size);

/**
 * Unpack message EBCC_Engine_Exhaust_Brake_Cont.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_ebcc_engine_exhaust_brake_cont_unpack(
    struct dura_max_ebcc_engine_exhaust_brake_cont_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EBCC_Engine_Exhaust_Brake_Cont.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_ebcc_engine_exhaust_brake_cont_init(struct dura_max_ebcc_engine_exhaust_brake_cont_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebcc_engine_exhaust_brake_cont_actual_boost_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebcc_engine_exhaust_brake_cont_actual_boost_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebcc_engine_exhaust_brake_cont_actual_boost_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebcc_engine_exhaust_brake_cont_desired_boost_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebcc_engine_exhaust_brake_cont_desired_boost_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebcc_engine_exhaust_brake_cont_desired_boost_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebcc_engine_exhaust_brake_cont_engine_exhaust_brake_actuator_co_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebcc_engine_exhaust_brake_cont_engine_exhaust_brake_actuator_co_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebcc_engine_exhaust_brake_cont_engine_exhaust_brake_actuator_co_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebcc_engine_exhaust_brake_cont_engine_turbocharger_2_turbine_ou_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebcc_engine_exhaust_brake_cont_engine_turbocharger_2_turbine_ou_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebcc_engine_exhaust_brake_cont_engine_turbocharger_2_turbine_ou_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebcc_engine_exhaust_brake_cont_desired_engine_turbocharger_2_tu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebcc_engine_exhaust_brake_cont_desired_engine_turbocharger_2_tu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebcc_engine_exhaust_brake_cont_desired_engine_turbocharger_2_tu_is_in_range(uint8_t value);

/**
 * Pack message ET3_Engine_Temperature_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_et3_engine_temperature_3_pack(
    uint8_t *dst_p,
    const struct dura_max_et3_engine_temperature_3_t *src_p,
    size_t size);

/**
 * Unpack message ET3_Engine_Temperature_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_et3_engine_temperature_3_unpack(
    struct dura_max_et3_engine_temperature_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ET3_Engine_Temperature_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_et3_engine_temperature_3_init(struct dura_max_et3_engine_temperature_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_et3_engine_temperature_3_engine_intake_manifold_1_air_tem_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et3_engine_temperature_3_engine_intake_manifold_1_air_tem_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et3_engine_temperature_3_engine_intake_manifold_1_air_tem_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_et3_engine_temperature_3_engine_coolant_temperature_high_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et3_engine_temperature_3_engine_coolant_temperature_high_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et3_engine_temperature_3_engine_coolant_temperature_high_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_et3_engine_temperature_3_engine_intake_valve_actuation_sy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et3_engine_temperature_3_engine_intake_valve_actuation_sy_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et3_engine_temperature_3_engine_intake_valve_actuation_sy_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_et3_engine_temperature_3_engine_cac_outlet_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et3_engine_temperature_3_engine_cac_outlet_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et3_engine_temperature_3_engine_cac_outlet_temperature_is_in_range(uint16_t value);

/**
 * Pack message DM21_Diagnostic_Readiness_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_dm21_diagnostic_readiness_2_pack(
    uint8_t *dst_p,
    const struct dura_max_dm21_diagnostic_readiness_2_t *src_p,
    size_t size);

/**
 * Unpack message DM21_Diagnostic_Readiness_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_dm21_diagnostic_readiness_2_unpack(
    struct dura_max_dm21_diagnostic_readiness_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DM21_Diagnostic_Readiness_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_dm21_diagnostic_readiness_2_init(struct dura_max_dm21_diagnostic_readiness_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_dm21_diagnostic_readiness_2_engine_run_time_with_mil_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm21_diagnostic_readiness_2_engine_run_time_with_mil_on_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm21_diagnostic_readiness_2_engine_run_time_with_mil_on_is_in_range(uint16_t value);

/**
 * Pack message DM26_Diagnostic_Readiness_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_dm26_diagnostic_readiness_3_pack(
    uint8_t *dst_p,
    const struct dura_max_dm26_diagnostic_readiness_3_t *src_p,
    size_t size);

/**
 * Unpack message DM26_Diagnostic_Readiness_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_dm26_diagnostic_readiness_3_unpack(
    struct dura_max_dm26_diagnostic_readiness_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DM26_Diagnostic_Readiness_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_dm26_diagnostic_readiness_3_init(struct dura_max_dm26_diagnostic_readiness_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_dm26_diagnostic_readiness_3_time_since_engine_start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm26_diagnostic_readiness_3_time_since_engine_start_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm26_diagnostic_readiness_3_time_since_engine_start_is_in_range(uint16_t value);

/**
 * Pack message IC1_Intake_Exhaust_Cond_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_ic1_intake_exhaust_cond_1_pack(
    uint8_t *dst_p,
    const struct dura_max_ic1_intake_exhaust_cond_1_t *src_p,
    size_t size);

/**
 * Unpack message IC1_Intake_Exhaust_Cond_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_ic1_intake_exhaust_cond_1_unpack(
    struct dura_max_ic1_intake_exhaust_cond_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IC1_Intake_Exhaust_Cond_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_ic1_intake_exhaust_cond_1_init(struct dura_max_ic1_intake_exhaust_cond_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ic1_intake_exhaust_cond_1_aft1_dpf_in_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ic1_intake_exhaust_cond_1_aft1_dpf_in_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ic1_intake_exhaust_cond_1_aft1_dpf_in_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ic1_intake_exhaust_cond_1_eng_intake_manifold1_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ic1_intake_exhaust_cond_1_eng_intake_manifold1_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ic1_intake_exhaust_cond_1_eng_intake_manifold1_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ic1_intake_exhaust_cond_1_eng_intake_manifold1_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ic1_intake_exhaust_cond_1_eng_intake_manifold1_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ic1_intake_exhaust_cond_1_eng_intake_manifold1_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ic1_intake_exhaust_cond_1_eng_air_intake_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ic1_intake_exhaust_cond_1_eng_air_intake_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ic1_intake_exhaust_cond_1_eng_air_intake_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ic1_intake_exhaust_cond_1_eng_air_filter1_diff_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ic1_intake_exhaust_cond_1_eng_air_filter1_diff_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ic1_intake_exhaust_cond_1_eng_air_filter1_diff_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_ic1_intake_exhaust_cond_1_eng_exhaust_gas_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ic1_intake_exhaust_cond_1_eng_exhaust_gas_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ic1_intake_exhaust_cond_1_eng_exhaust_gas_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ic1_intake_exhaust_cond_1_eng_coolant_filter_diff_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ic1_intake_exhaust_cond_1_eng_coolant_filter_diff_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ic1_intake_exhaust_cond_1_eng_coolant_filter_diff_press_is_in_range(uint8_t value);

/**
 * Pack message AMB_Ambient_Conditions.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_amb_ambient_conditions_pack(
    uint8_t *dst_p,
    const struct dura_max_amb_ambient_conditions_t *src_p,
    size_t size);

/**
 * Unpack message AMB_Ambient_Conditions.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_amb_ambient_conditions_unpack(
    struct dura_max_amb_ambient_conditions_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AMB_Ambient_Conditions.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_amb_ambient_conditions_init(struct dura_max_amb_ambient_conditions_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_amb_ambient_conditions_barometric_pressure_barometric_pr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_amb_ambient_conditions_barometric_pressure_barometric_pr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_amb_ambient_conditions_barometric_pressure_barometric_pr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_amb_ambient_conditions_cab_interior_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_amb_ambient_conditions_cab_interior_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_amb_ambient_conditions_cab_interior_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_amb_ambient_conditions_ambient_air_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_amb_ambient_conditions_ambient_air_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_amb_ambient_conditions_ambient_air_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_amb_ambient_conditions_engine_air_intake_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_amb_ambient_conditions_engine_air_intake_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_amb_ambient_conditions_engine_air_intake_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_amb_ambient_conditions_road_surface_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_amb_ambient_conditions_road_surface_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_amb_ambient_conditions_road_surface_temp_is_in_range(uint16_t value);

/**
 * Pack message EEC1_Electronic_Engine_Control_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_eec1_electronic_engine_control_1_pack(
    uint8_t *dst_p,
    const struct dura_max_eec1_electronic_engine_control_1_t *src_p,
    size_t size);

/**
 * Unpack message EEC1_Electronic_Engine_Control_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_eec1_electronic_engine_control_1_unpack(
    struct dura_max_eec1_electronic_engine_control_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EEC1_Electronic_Engine_Control_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_eec1_electronic_engine_control_1_init(struct dura_max_eec1_electronic_engine_control_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec1_electronic_engine_control_1_engine_torque_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_engine_torque_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_engine_torque_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec1_electronic_engine_control_1_actl_eng_prcnt_torque_high_resolution_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_actl_eng_prcnt_torque_high_resolution_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_actl_eng_prcnt_torque_high_resolution_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec1_electronic_engine_control_1_drivers_demand_engine_prcnt_torq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_drivers_demand_engine_prcnt_torq_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_drivers_demand_engine_prcnt_torq_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec1_electronic_engine_control_1_actual_engine_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_actual_engine_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_actual_engine_percent_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec1_electronic_engine_control_1_engine_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_engine_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_engine_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec1_electronic_engine_control_1_src_addrss_of_cntrllng_dvc_for_eng_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_src_addrss_of_cntrllng_dvc_for_eng_ctrl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_src_addrss_of_cntrllng_dvc_for_eng_ctrl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec1_electronic_engine_control_1_eng_starter_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_eng_starter_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_eng_starter_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec1_electronic_engine_control_1_engine_demand_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec1_electronic_engine_control_1_engine_demand_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec1_electronic_engine_control_1_engine_demand_percent_torque_is_in_range(uint8_t value);

/**
 * Pack message EEC2_Electronic_Engine_Control_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_eec2_electronic_engine_control_2_pack(
    uint8_t *dst_p,
    const struct dura_max_eec2_electronic_engine_control_2_t *src_p,
    size_t size);

/**
 * Unpack message EEC2_Electronic_Engine_Control_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_eec2_electronic_engine_control_2_unpack(
    struct dura_max_eec2_electronic_engine_control_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EEC2_Electronic_Engine_Control_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_eec2_electronic_engine_control_2_init(struct dura_max_eec2_electronic_engine_control_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_accel_pedal1_low_idle_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_accel_pedal1_low_idle_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_accel_pedal1_low_idle_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_accel_pedal_kickdown_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_accel_pedal_kickdown_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_accel_pedal_kickdown_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_road_speed_limit_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_road_speed_limit_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_road_speed_limit_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_accel_pedal2_low_idle_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_accel_pedal2_low_idle_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_accel_pedal2_low_idle_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_accel_pedal_pos1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_accel_pedal_pos1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_accel_pedal_pos1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_eng_percent_load_at_current_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_eng_percent_load_at_current_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_eng_percent_load_at_current_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_remote_accel_pedal_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_remote_accel_pedal_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_remote_accel_pedal_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_accel_pedal_pos2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_accel_pedal_pos2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_accel_pedal_pos2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_vhcle_acceleration_rate_limit_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_vhcle_acceleration_rate_limit_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_vhcle_acceleration_rate_limit_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_mmntary_eng_max_power_enable_feedback_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_mmntary_eng_max_power_enable_feedback_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_mmntary_eng_max_power_enable_feedback_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_dpf_thermal_management_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_dpf_thermal_management_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_dpf_thermal_management_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_scr_thermal_management_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_scr_thermal_management_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_scr_thermal_management_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_actl_max_available_eng_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_actl_max_available_eng_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_actl_max_available_eng_percent_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec2_electronic_engine_control_2_est_pumping_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec2_electronic_engine_control_2_est_pumping_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec2_electronic_engine_control_2_est_pumping_percent_torque_is_in_range(uint8_t value);

/**
 * Pack message EEC3_Electronic_Engine_Control_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_eec3_electronic_engine_control_3_pack(
    uint8_t *dst_p,
    const struct dura_max_eec3_electronic_engine_control_3_t *src_p,
    size_t size);

/**
 * Unpack message EEC3_Electronic_Engine_Control_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_eec3_electronic_engine_control_3_unpack(
    struct dura_max_eec3_electronic_engine_control_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EEC3_Electronic_Engine_Control_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_eec3_electronic_engine_control_3_init(struct dura_max_eec3_electronic_engine_control_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec3_electronic_engine_control_3_nominal_friction_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_nominal_friction_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_nominal_friction_percent_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec3_electronic_engine_control_3_engines_desired_operating_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_engines_desired_operating_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_engines_desired_operating_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec3_electronic_engine_control_3_engns_dsrd_oprtng_spd_asymmtry_adjstm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_engns_dsrd_oprtng_spd_asymmtry_adjstm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_engns_dsrd_oprtng_spd_asymmtry_adjstm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec3_electronic_engine_control_3_est_eng_prsitic_losses_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_est_eng_prsitic_losses_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_est_eng_prsitic_losses_percent_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec3_electronic_engine_control_3_aft1_exh_gas_mfr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_aft1_exh_gas_mfr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_aft1_exh_gas_mfr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec3_electronic_engine_control_3_aft1_in_dew_point_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_aft1_in_dew_point_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_aft1_in_dew_point_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec3_electronic_engine_control_3_aft1_exh_dew_point_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_aft1_exh_dew_point_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_aft1_exh_dew_point_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec3_electronic_engine_control_3_aft2_in_dew_point_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_aft2_in_dew_point_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_aft2_in_dew_point_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_eec3_electronic_engine_control_3_aft2_exh_dew_point_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec3_electronic_engine_control_3_aft2_exh_dew_point_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec3_electronic_engine_control_3_aft2_exh_dew_point_is_in_range(uint8_t value);

/**
 * Pack message EFL_P1_Eng_Fluid_Level_Press_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_efl_p1_eng_fluid_level_press_1_pack(
    uint8_t *dst_p,
    const struct dura_max_efl_p1_eng_fluid_level_press_1_t *src_p,
    size_t size);

/**
 * Unpack message EFL_P1_Eng_Fluid_Level_Press_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_efl_p1_eng_fluid_level_press_1_unpack(
    struct dura_max_efl_p1_eng_fluid_level_press_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EFL_P1_Eng_Fluid_Level_Press_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_efl_p1_eng_fluid_level_press_1_init(struct dura_max_efl_p1_eng_fluid_level_press_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_efl_p1_eng_fluid_level_press_1_eng_fuel_delivery_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p1_eng_fluid_level_press_1_eng_fuel_delivery_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p1_eng_fluid_level_press_1_eng_fuel_delivery_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_efl_p1_eng_fluid_level_press_1_eng_ex_crankcase_blowby_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p1_eng_fluid_level_press_1_eng_ex_crankcase_blowby_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p1_eng_fluid_level_press_1_eng_ex_crankcase_blowby_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_efl_p1_eng_fluid_level_press_1_eng_oil_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p1_eng_fluid_level_press_1_eng_oil_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p1_eng_fluid_level_press_1_eng_oil_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_efl_p1_eng_fluid_level_press_1_eng_oil_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p1_eng_fluid_level_press_1_eng_oil_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p1_eng_fluid_level_press_1_eng_oil_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_efl_p1_eng_fluid_level_press_1_eng_crankcase_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p1_eng_fluid_level_press_1_eng_crankcase_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p1_eng_fluid_level_press_1_eng_crankcase_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_efl_p1_eng_fluid_level_press_1_eng_coolant_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p1_eng_fluid_level_press_1_eng_coolant_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p1_eng_fluid_level_press_1_eng_coolant_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_efl_p1_eng_fluid_level_press_1_eng_coolant_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p1_eng_fluid_level_press_1_eng_coolant_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p1_eng_fluid_level_press_1_eng_coolant_level_is_in_range(uint8_t value);

/**
 * Pack message EFL_P2_Eng_Fluid_Level_Press_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_efl_p2_eng_fluid_level_press_2_pack(
    uint8_t *dst_p,
    const struct dura_max_efl_p2_eng_fluid_level_press_2_t *src_p,
    size_t size);

/**
 * Unpack message EFL_P2_Eng_Fluid_Level_Press_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_efl_p2_eng_fluid_level_press_2_unpack(
    struct dura_max_efl_p2_eng_fluid_level_press_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EFL_P2_Eng_Fluid_Level_Press_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_efl_p2_eng_fluid_level_press_2_init(struct dura_max_efl_p2_eng_fluid_level_press_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_efl_p2_eng_fluid_level_press_2_eng_injection_ctrl_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p2_eng_fluid_level_press_2_eng_injection_ctrl_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p2_eng_fluid_level_press_2_eng_injection_ctrl_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_metering_rail1_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_metering_rail1_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_metering_rail1_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_timing_rail1_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_timing_rail1_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_timing_rail1_press_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_metering_rail2_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_metering_rail2_press_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_efl_p2_eng_fluid_level_press_2_eng_injector_metering_rail2_press_is_in_range(uint16_t value);

/**
 * Pack message ET1_Engine_Temperature_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_et1_engine_temperature_1_pack(
    uint8_t *dst_p,
    const struct dura_max_et1_engine_temperature_1_t *src_p,
    size_t size);

/**
 * Unpack message ET1_Engine_Temperature_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_et1_engine_temperature_1_unpack(
    struct dura_max_et1_engine_temperature_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ET1_Engine_Temperature_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_et1_engine_temperature_1_init(struct dura_max_et1_engine_temperature_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_et1_engine_temperature_1_eng_coolant_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et1_engine_temperature_1_eng_coolant_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et1_engine_temperature_1_eng_coolant_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_et1_engine_temperature_1_eng_fuel_temp1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et1_engine_temperature_1_eng_fuel_temp1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et1_engine_temperature_1_eng_fuel_temp1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_et1_engine_temperature_1_eng_oil_temp1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et1_engine_temperature_1_eng_oil_temp1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et1_engine_temperature_1_eng_oil_temp1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_et1_engine_temperature_1_eng_turbo_oil_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et1_engine_temperature_1_eng_turbo_oil_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et1_engine_temperature_1_eng_turbo_oil_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_et1_engine_temperature_1_eng_intercooler_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et1_engine_temperature_1_eng_intercooler_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et1_engine_temperature_1_eng_intercooler_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_et1_engine_temperature_1_eng_intercooler_thermostat_opening_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_et1_engine_temperature_1_eng_intercooler_thermostat_opening_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_et1_engine_temperature_1_eng_intercooler_thermostat_opening_is_in_range(uint8_t value);

/**
 * Pack message LFE1_Fuel_Economy_Liquid_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_lfe1_fuel_economy_liquid_1_pack(
    uint8_t *dst_p,
    const struct dura_max_lfe1_fuel_economy_liquid_1_t *src_p,
    size_t size);

/**
 * Unpack message LFE1_Fuel_Economy_Liquid_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_lfe1_fuel_economy_liquid_1_unpack(
    struct dura_max_lfe1_fuel_economy_liquid_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LFE1_Fuel_Economy_Liquid_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_lfe1_fuel_economy_liquid_1_init(struct dura_max_lfe1_fuel_economy_liquid_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_lfe1_fuel_economy_liquid_1_eng_fuel_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_lfe1_fuel_economy_liquid_1_eng_fuel_rate_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_lfe1_fuel_economy_liquid_1_eng_fuel_rate_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_lfe1_fuel_economy_liquid_1_eng_instantaneous_fuel_economy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_lfe1_fuel_economy_liquid_1_eng_instantaneous_fuel_economy_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_lfe1_fuel_economy_liquid_1_eng_instantaneous_fuel_economy_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_lfe1_fuel_economy_liquid_1_eng_average_fuel_economy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_lfe1_fuel_economy_liquid_1_eng_average_fuel_economy_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_lfe1_fuel_economy_liquid_1_eng_average_fuel_economy_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_lfe1_fuel_economy_liquid_1_eng_throttle_valve1_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_lfe1_fuel_economy_liquid_1_eng_throttle_valve1_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_lfe1_fuel_economy_liquid_1_eng_throttle_valve1_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_lfe1_fuel_economy_liquid_1_eng_throttle_valve2_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_lfe1_fuel_economy_liquid_1_eng_throttle_valve2_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_lfe1_fuel_economy_liquid_1_eng_throttle_valve2_pos_is_in_range(uint8_t value);

/**
 * Pack message TransportProtocol_Header.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_transport_protocol_header_pack(
    uint8_t *dst_p,
    const struct dura_max_transport_protocol_header_t *src_p,
    size_t size);

/**
 * Unpack message TransportProtocol_Header.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_transport_protocol_header_unpack(
    struct dura_max_transport_protocol_header_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TransportProtocol_Header.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_transport_protocol_header_init(struct dura_max_transport_protocol_header_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_control_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_control_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_control_byte_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_transport_protocol_header_total_message_size_eo_ma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_total_message_size_eo_ma_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_total_message_size_eo_ma_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_connection_abort_reason_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_connection_abort_reason_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_connection_abort_reason_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_transport_protocol_header_total_message_size_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_total_message_size_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_total_message_size_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_number_of_packets_that_can_be_sent_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_number_of_packets_that_can_be_sent_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_number_of_packets_that_can_be_sent_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_transport_protocol_header_total_message_size_bam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_total_message_size_bam_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_total_message_size_bam_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_next_packet_number_to_be_sent_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_next_packet_number_to_be_sent_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_next_packet_number_to_be_sent_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_total_number_of_packets_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_total_number_of_packets_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_total_number_of_packets_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_total_number_of_packets_eo_ma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_total_number_of_packets_eo_ma_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_total_number_of_packets_eo_ma_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_total_number_of_packets_bam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_total_number_of_packets_bam_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_total_number_of_packets_bam_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_header_maximum_number_of_packets_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_maximum_number_of_packets_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_maximum_number_of_packets_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_transport_protocol_header_pg_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_header_pg_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_header_pg_number_is_in_range(uint32_t value);

/**
 * Pack message TransportProtocol_Data.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_transport_protocol_data_pack(
    uint8_t *dst_p,
    const struct dura_max_transport_protocol_data_t *src_p,
    size_t size);

/**
 * Unpack message TransportProtocol_Data.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_transport_protocol_data_unpack(
    struct dura_max_transport_protocol_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TransportProtocol_Data.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_transport_protocol_data_init(struct dura_max_transport_protocol_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_transport_protocol_data_sequence_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_transport_protocol_data_sequence_number_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_transport_protocol_data_sequence_number_is_in_range(uint8_t value);

/**
 * Pack message DM01_Active_Diagnostics.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_dm01_active_diagnostics_pack(
    uint8_t *dst_p,
    const struct dura_max_dm01_active_diagnostics_t *src_p,
    size_t size);

/**
 * Unpack message DM01_Active_Diagnostics.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_dm01_active_diagnostics_unpack(
    struct dura_max_dm01_active_diagnostics_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DM01_Active_Diagnostics.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_dm01_active_diagnostics_init(struct dura_max_dm01_active_diagnostics_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_protect_lamp_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_protect_lamp_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_protect_lamp_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_amber_warning_lamp_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_amber_warning_lamp_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_amber_warning_lamp_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_red_stop_lamp_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_red_stop_lamp_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_red_stop_lamp_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_malfunction_indicator_lamp_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_malfunction_indicator_lamp_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_malfunction_indicator_lamp_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_flash_protect_lamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_flash_protect_lamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_flash_protect_lamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_flash_amber_warning_lamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_flash_amber_warning_lamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_flash_amber_warning_lamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_flash_red_stop_lamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_flash_red_stop_lamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_flash_red_stop_lamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm01_active_diagnostics_flash_malfunc_indicator_lamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_flash_malfunc_indicator_lamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_flash_malfunc_indicator_lamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_dm01_active_diagnostics_dtc1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm01_active_diagnostics_dtc1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm01_active_diagnostics_dtc1_is_in_range(uint32_t value);

/**
 * Pack message TSC1_31.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_tsc1_31_pack(
    uint8_t *dst_p,
    const struct dura_max_tsc1_31_t *src_p,
    size_t size);

/**
 * Unpack message TSC1_31.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_tsc1_31_unpack(
    struct dura_max_tsc1_31_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TSC1_31.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_tsc1_31_init(struct dura_max_tsc1_31_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_eng_override_ctrl_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_eng_override_ctrl_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_eng_override_ctrl_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_eng_requested_speed_ctrl_conditions_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_eng_requested_speed_ctrl_conditions_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_eng_requested_speed_ctrl_conditions_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_override_ctrl_mode_priority_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_override_ctrl_mode_priority_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_override_ctrl_mode_priority_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tsc1_31_eng_requested_speed_speed_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_eng_requested_speed_speed_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_eng_requested_speed_speed_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_eng_requested_torque_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_eng_requested_torque_torque_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_eng_requested_torque_torque_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_tsc1_trans_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_tsc1_trans_rate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_tsc1_trans_rate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_tsc1_ctrl_purpose_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_tsc1_ctrl_purpose_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_tsc1_ctrl_purpose_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_eng_requested_torque_high_resolution_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_eng_requested_torque_high_resolution_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_eng_requested_torque_high_resolution_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_message_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_message_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_message_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_31_message_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_31_message_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_31_message_checksum_is_in_range(uint8_t value);

/**
 * Pack message CAC1_Charge_Air_Cooler_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_cac1_charge_air_cooler_1_pack(
    uint8_t *dst_p,
    const struct dura_max_cac1_charge_air_cooler_1_t *src_p,
    size_t size);

/**
 * Unpack message CAC1_Charge_Air_Cooler_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_cac1_charge_air_cooler_1_unpack(
    struct dura_max_cac1_charge_air_cooler_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CAC1_Charge_Air_Cooler_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_cac1_charge_air_cooler_1_init(struct dura_max_cac1_charge_air_cooler_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_intak_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_intak_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_intak_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_ambie_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_ambie_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_ambie_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_effic_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_effic_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_cac1_charge_air_cooler_1_engine_charge_air_cooler_1_effic_is_in_range(uint8_t value);

/**
 * Pack message HOURS_Engine_Hours_Revolutions.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_hours_engine_hours_revolutions_pack(
    uint8_t *dst_p,
    const struct dura_max_hours_engine_hours_revolutions_t *src_p,
    size_t size);

/**
 * Unpack message HOURS_Engine_Hours_Revolutions.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_hours_engine_hours_revolutions_unpack(
    struct dura_max_hours_engine_hours_revolutions_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HOURS_Engine_Hours_Revolutions.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_hours_engine_hours_revolutions_init(struct dura_max_hours_engine_hours_revolutions_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_hours_engine_hours_revolutions_engine_total_hours_of_operation__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_hours_engine_hours_revolutions_engine_total_hours_of_operation__decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_hours_engine_hours_revolutions_engine_total_hours_of_operation__is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_hours_engine_hours_revolutions_engine_total_revolutions_249__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_hours_engine_hours_revolutions_engine_total_revolutions_249__decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_hours_engine_hours_revolutions_engine_total_revolutions_249__is_in_range(uint32_t value);

/**
 * Pack message TCI5_Turbocharger_Information_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_tci5_turbocharger_information_5_pack(
    uint8_t *dst_p,
    const struct dura_max_tci5_turbocharger_information_5_t *src_p,
    size_t size);

/**
 * Unpack message TCI5_Turbocharger_Information_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_tci5_turbocharger_information_5_unpack(
    struct dura_max_tci5_turbocharger_information_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TCI5_Turbocharger_Information_5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_tci5_turbocharger_information_5_init(struct dura_max_tci5_turbocharger_information_5_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tci5_turbocharger_information_5_engine_turbocharger_1_turbine_ou_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci5_turbocharger_information_5_engine_turbocharger_1_turbine_ou_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci5_turbocharger_information_5_engine_turbocharger_1_turbine_ou_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tci5_turbocharger_information_5_engine_turbocharger_2_turbine_ou_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci5_turbocharger_information_5_engine_turbocharger_2_turbine_ou_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci5_turbocharger_information_5_engine_turbocharger_2_turbine_ou_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tci5_turbocharger_information_5_engine_turbocharger_3_turbine_ou_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci5_turbocharger_information_5_engine_turbocharger_3_turbine_ou_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci5_turbocharger_information_5_engine_turbocharger_3_turbine_ou_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tci5_turbocharger_information_5_engine_turbocharger_4_turbine_ou_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci5_turbocharger_information_5_engine_turbocharger_4_turbine_ou_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci5_turbocharger_information_5_engine_turbocharger_4_turbine_ou_is_in_range(uint16_t value);

/**
 * Pack message VEP1_Vehicle_Electrical_Power_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_vep1_vehicle_electrical_power_1_pack(
    uint8_t *dst_p,
    const struct dura_max_vep1_vehicle_electrical_power_1_t *src_p,
    size_t size);

/**
 * Unpack message VEP1_Vehicle_Electrical_Power_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_vep1_vehicle_electrical_power_1_unpack(
    struct dura_max_vep1_vehicle_electrical_power_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VEP1_Vehicle_Electrical_Power_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_vep1_vehicle_electrical_power_1_init(struct dura_max_vep1_vehicle_electrical_power_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_vep1_vehicle_electrical_power_1_net_battery_current_114__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_vep1_vehicle_electrical_power_1_net_battery_current_114__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_vep1_vehicle_electrical_power_1_net_battery_current_114__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_vep1_vehicle_electrical_power_1_alternator_current_115__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_vep1_vehicle_electrical_power_1_alternator_current_115__decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_vep1_vehicle_electrical_power_1_alternator_current_115__is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_vep1_vehicle_electrical_power_1_charging_system_potential_volta_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_vep1_vehicle_electrical_power_1_charging_system_potential_volta_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_vep1_vehicle_electrical_power_1_charging_system_potential_volta_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_vep1_vehicle_electrical_power_1_battery_potential_power_input_1__encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_vep1_vehicle_electrical_power_1_battery_potential_power_input_1__decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_vep1_vehicle_electrical_power_1_battery_potential_power_input_1__is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_vep1_vehicle_electrical_power_1_keyswitch_battery_potential_158_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_vep1_vehicle_electrical_power_1_keyswitch_battery_potential_158_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_vep1_vehicle_electrical_power_1_keyswitch_battery_potential_158_is_in_range(uint16_t value);

/**
 * Pack message EEC20_Electronic_Engine_Control_.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_eec20_electronic_engine_control__pack(
    uint8_t *dst_p,
    const struct dura_max_eec20_electronic_engine_control__t *src_p,
    size_t size);

/**
 * Unpack message EEC20_Electronic_Engine_Control_.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_eec20_electronic_engine_control__unpack(
    struct dura_max_eec20_electronic_engine_control__t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EEC20_Electronic_Engine_Control_.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_eec20_electronic_engine_control__init(struct dura_max_eec20_electronic_engine_control__t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_eec20_electronic_engine_control__absolute_engine_load_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_eec20_electronic_engine_control__absolute_engine_load_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_eec20_electronic_engine_control__absolute_engine_load_is_in_range(uint16_t value);

/**
 * Pack message EASI_Engine_Air_System_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_easi_engine_air_system_info_pack(
    uint8_t *dst_p,
    const struct dura_max_easi_engine_air_system_info_t *src_p,
    size_t size);

/**
 * Unpack message EASI_Engine_Air_System_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_easi_engine_air_system_info_unpack(
    struct dura_max_easi_engine_air_system_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EASI_Engine_Air_System_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_easi_engine_air_system_info_init(struct dura_max_easi_engine_air_system_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_easi_engine_air_system_info_engine_intake_maf_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_easi_engine_air_system_info_engine_intake_maf_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_easi_engine_air_system_info_engine_intake_maf_is_in_range(uint16_t value);

/**
 * Pack message TSC1_03.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_tsc1_03_pack(
    uint8_t *dst_p,
    const struct dura_max_tsc1_03_t *src_p,
    size_t size);

/**
 * Unpack message TSC1_03.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_tsc1_03_unpack(
    struct dura_max_tsc1_03_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TSC1_03.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_tsc1_03_init(struct dura_max_tsc1_03_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_eng_override_ctrl_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_eng_override_ctrl_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_eng_override_ctrl_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_eng_requested_speed_ctrl_conditions_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_eng_requested_speed_ctrl_conditions_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_eng_requested_speed_ctrl_conditions_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_override_ctrl_mode_priority_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_override_ctrl_mode_priority_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_override_ctrl_mode_priority_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tsc1_03_eng_requested_speed_speed_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_eng_requested_speed_speed_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_eng_requested_speed_speed_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_eng_requested_torque_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_eng_requested_torque_torque_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_eng_requested_torque_torque_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_tsc1_trans_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_tsc1_trans_rate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_tsc1_trans_rate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_tsc1_ctrl_purpose_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_tsc1_ctrl_purpose_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_tsc1_ctrl_purpose_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_eng_requested_torque_high_resolution_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_eng_requested_torque_high_resolution_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_eng_requested_torque_high_resolution_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_message_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_message_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_message_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_03_message_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_03_message_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_03_message_checksum_is_in_range(uint8_t value);

/**
 * Pack message TSC1_0B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_tsc1_0_b_pack(
    uint8_t *dst_p,
    const struct dura_max_tsc1_0_b_t *src_p,
    size_t size);

/**
 * Unpack message TSC1_0B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_tsc1_0_b_unpack(
    struct dura_max_tsc1_0_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TSC1_0B.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_tsc1_0_b_init(struct dura_max_tsc1_0_b_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_eng_override_ctrl_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_eng_override_ctrl_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_eng_override_ctrl_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_eng_requested_speed_ctrl_conditions_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_eng_requested_speed_ctrl_conditions_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_eng_requested_speed_ctrl_conditions_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_override_ctrl_mode_priority_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_override_ctrl_mode_priority_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_override_ctrl_mode_priority_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tsc1_0_b_eng_requested_speed_speed_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_eng_requested_speed_speed_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_eng_requested_speed_speed_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_eng_requested_torque_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_eng_requested_torque_torque_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_eng_requested_torque_torque_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_tsc1_trans_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_tsc1_trans_rate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_tsc1_trans_rate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_tsc1_ctrl_purpose_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_tsc1_ctrl_purpose_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_tsc1_ctrl_purpose_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_eng_requested_torque_high_resolution_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_eng_requested_torque_high_resolution_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_eng_requested_torque_high_resolution_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_message_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_message_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_message_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tsc1_0_b_message_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tsc1_0_b_message_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tsc1_0_b_message_checksum_is_in_range(uint8_t value);

/**
 * Pack message DM07.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_dm07_pack(
    uint8_t *dst_p,
    const struct dura_max_dm07_t *src_p,
    size_t size);

/**
 * Unpack message DM07.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_dm07_unpack(
    struct dura_max_dm07_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DM07.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_dm07_init(struct dura_max_dm07_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm07_test_identifier_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm07_test_identifier_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm07_test_identifier_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_dm07_spn1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm07_spn1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm07_spn1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm07_failure_mode_identifier1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm07_failure_mode_identifier1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm07_failure_mode_identifier1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm07_spn1_high_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm07_spn1_high_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm07_spn1_high_is_in_range(uint8_t value);

/**
 * Pack message DM08.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_dm08_pack(
    uint8_t *dst_p,
    const struct dura_max_dm08_t *src_p,
    size_t size);

/**
 * Unpack message DM08.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_dm08_unpack(
    struct dura_max_dm08_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DM08.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_dm08_init(struct dura_max_dm08_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm08_test_identifier_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm08_test_identifier_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm08_test_identifier_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_dm08_test_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm08_test_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm08_test_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_dm08_test_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm08_test_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm08_test_value_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_dm08_test_limit_maximum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm08_test_limit_maximum_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm08_test_limit_maximum_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_dm08_test_limit_minimum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_dm08_test_limit_minimum_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_dm08_test_limit_minimum_is_in_range(uint16_t value);

/**
 * Pack message ERC1_Electronic_Retarder_Cntrl.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_erc1_electronic_retarder_cntrl_pack(
    uint8_t *dst_p,
    const struct dura_max_erc1_electronic_retarder_cntrl_t *src_p,
    size_t size);

/**
 * Unpack message ERC1_Electronic_Retarder_Cntrl.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_erc1_electronic_retarder_cntrl_unpack(
    struct dura_max_erc1_electronic_retarder_cntrl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ERC1_Electronic_Retarder_Cntrl.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_erc1_electronic_retarder_cntrl_init(struct dura_max_erc1_electronic_retarder_cntrl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_retarder_torque_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_retarder_torque_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_retarder_torque_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_retarder_enable_brake_assist_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_retarder_enable_brake_assist_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_retarder_enable_brake_assist_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_retarder_enable_shift_assist_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_retarder_enable_shift_assist_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_retarder_enable_shift_assist_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_actual_retarder_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_actual_retarder_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_actual_retarder_percent_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_intended_retarder_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_intended_retarder_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_intended_retarder_percent_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_eng_coolant_load_increase_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_eng_coolant_load_increase_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_eng_coolant_load_increase_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_retarder_requesting_brake_light_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_retarder_requesting_brake_light_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_retarder_requesting_brake_light_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_retarder_road_speed_limit_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_retarder_road_speed_limit_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_retarder_road_speed_limit_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_retarder_road_speed_exceeded_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_retarder_road_speed_exceeded_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_retarder_road_speed_exceeded_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_src_addrss_of_cntrllng_dvc_fr_rtrdr_ctr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_src_addrss_of_cntrllng_dvc_fr_rtrdr_ctr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_src_addrss_of_cntrllng_dvc_fr_rtrdr_ctr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_drvrs_demand_retarder_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_drvrs_demand_retarder_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_drvrs_demand_retarder_percent_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_retarder_selection_nonengine_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_retarder_selection_nonengine_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_retarder_selection_nonengine_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_erc1_electronic_retarder_cntrl_actl_mx_avlbl_retarder_percent_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_erc1_electronic_retarder_cntrl_actl_mx_avlbl_retarder_percent_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_erc1_electronic_retarder_cntrl_actl_mx_avlbl_retarder_percent_torque_is_in_range(uint8_t value);

/**
 * Pack message ETC1_Electronic_Trans_Cntrl_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_etc1_electronic_trans_cntrl_1_pack(
    uint8_t *dst_p,
    const struct dura_max_etc1_electronic_trans_cntrl_1_t *src_p,
    size_t size);

/**
 * Unpack message ETC1_Electronic_Trans_Cntrl_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_etc1_electronic_trans_cntrl_1_unpack(
    struct dura_max_etc1_electronic_trans_cntrl_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ETC1_Electronic_Trans_Cntrl_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_etc1_electronic_trans_cntrl_1_init(struct dura_max_etc1_electronic_trans_cntrl_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_trans_driveline_engaged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_trans_driveline_engaged_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_trans_driveline_engaged_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_trns_torque_converter_lockup_engaged_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_trns_torque_converter_lockup_engaged_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_trns_torque_converter_lockup_engaged_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_trans_shift_in_process_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_trans_shift_in_process_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_trans_shift_in_process_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_trns_trq_cnvrtr_lckp_trnstn_in_process_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_trns_trq_cnvrtr_lckp_trnstn_in_process_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_trns_trq_cnvrtr_lckp_trnstn_in_process_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_etc1_electronic_trans_cntrl_1_trans_output_shaft_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_trans_output_shaft_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_trans_output_shaft_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_percent_clutch_slip_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_percent_clutch_slip_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_percent_clutch_slip_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_eng_momentary_overspeed_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_eng_momentary_overspeed_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_eng_momentary_overspeed_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_progressive_shift_disable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_progressive_shift_disable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_progressive_shift_disable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_momentary_eng_max_power_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_momentary_eng_max_power_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_momentary_eng_max_power_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_etc1_electronic_trans_cntrl_1_trans_input_shaft_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_trans_input_shaft_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_trans_input_shaft_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc1_electronic_trans_cntrl_1_src_addrss_of_cntrllng_dvc_fr_trns_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc1_electronic_trans_cntrl_1_src_addrss_of_cntrllng_dvc_fr_trns_ctrl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc1_electronic_trans_cntrl_1_src_addrss_of_cntrllng_dvc_fr_trns_ctrl_is_in_range(uint8_t value);

/**
 * Pack message ETC2_Electronic_Trans_Cntrl_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_etc2_electronic_trans_cntrl_2_pack(
    uint8_t *dst_p,
    const struct dura_max_etc2_electronic_trans_cntrl_2_t *src_p,
    size_t size);

/**
 * Unpack message ETC2_Electronic_Trans_Cntrl_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_etc2_electronic_trans_cntrl_2_unpack(
    struct dura_max_etc2_electronic_trans_cntrl_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ETC2_Electronic_Trans_Cntrl_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_etc2_electronic_trans_cntrl_2_init(struct dura_max_etc2_electronic_trans_cntrl_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc2_electronic_trans_cntrl_2_trans_selected_gear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc2_electronic_trans_cntrl_2_trans_selected_gear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc2_electronic_trans_cntrl_2_trans_selected_gear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_etc2_electronic_trans_cntrl_2_trans_actual_gear_ratio_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc2_electronic_trans_cntrl_2_trans_actual_gear_ratio_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc2_electronic_trans_cntrl_2_trans_actual_gear_ratio_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_etc2_electronic_trans_cntrl_2_trans_current_gear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc2_electronic_trans_cntrl_2_trans_current_gear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc2_electronic_trans_cntrl_2_trans_current_gear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_etc2_electronic_trans_cntrl_2_trans_requested_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc2_electronic_trans_cntrl_2_trans_requested_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc2_electronic_trans_cntrl_2_trans_requested_range_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_etc2_electronic_trans_cntrl_2_trans_current_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_etc2_electronic_trans_cntrl_2_trans_current_range_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_etc2_electronic_trans_cntrl_2_trans_current_range_is_in_range(uint16_t value);

/**
 * Pack message RQST_00_5E.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_rqst_00_5_e_pack(
    uint8_t *dst_p,
    const struct dura_max_rqst_00_5_e_t *src_p,
    size_t size);

/**
 * Unpack message RQST_00_5E.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_rqst_00_5_e_unpack(
    struct dura_max_rqst_00_5_e_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RQST_00_5E.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_rqst_00_5_e_init(struct dura_max_rqst_00_5_e_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_rqst_00_5_e_parameter_group_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_rqst_00_5_e_parameter_group_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_rqst_00_5_e_parameter_group_number_is_in_range(uint32_t value);

/**
 * Pack message RQST_00_21.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_rqst_00_21_pack(
    uint8_t *dst_p,
    const struct dura_max_rqst_00_21_t *src_p,
    size_t size);

/**
 * Unpack message RQST_00_21.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_rqst_00_21_unpack(
    struct dura_max_rqst_00_21_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RQST_00_21.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_rqst_00_21_init(struct dura_max_rqst_00_21_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_rqst_00_21_parameter_group_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_rqst_00_21_parameter_group_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_rqst_00_21_parameter_group_number_is_in_range(uint32_t value);

/**
 * Pack message RQST_Global_5E.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_rqst_global_5_e_pack(
    uint8_t *dst_p,
    const struct dura_max_rqst_global_5_e_t *src_p,
    size_t size);

/**
 * Unpack message RQST_Global_5E.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_rqst_global_5_e_unpack(
    struct dura_max_rqst_global_5_e_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RQST_Global_5E.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_rqst_global_5_e_init(struct dura_max_rqst_global_5_e_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_rqst_global_5_e_parameter_group_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_rqst_global_5_e_parameter_group_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_rqst_global_5_e_parameter_group_number_is_in_range(uint32_t value);

/**
 * Pack message RQST_Global_03.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_rqst_global_03_pack(
    uint8_t *dst_p,
    const struct dura_max_rqst_global_03_t *src_p,
    size_t size);

/**
 * Unpack message RQST_Global_03.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_rqst_global_03_unpack(
    struct dura_max_rqst_global_03_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RQST_Global_03.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_rqst_global_03_init(struct dura_max_rqst_global_03_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t dura_max_rqst_global_03_parameter_group_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_rqst_global_03_parameter_group_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_rqst_global_03_parameter_group_number_is_in_range(uint32_t value);

/**
 * Pack message TCI_Transfer_Case_Information.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_tci_transfer_case_information_pack(
    uint8_t *dst_p,
    const struct dura_max_tci_transfer_case_information_t *src_p,
    size_t size);

/**
 * Unpack message TCI_Transfer_Case_Information.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_tci_transfer_case_information_unpack(
    struct dura_max_tci_transfer_case_information_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TCI_Transfer_Case_Information.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_tci_transfer_case_information_init(struct dura_max_tci_transfer_case_information_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tci_transfer_case_information_transfer_case_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci_transfer_case_information_transfer_case_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci_transfer_case_information_transfer_case_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tci_transfer_case_information_dir_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci_transfer_case_information_dir_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci_transfer_case_information_dir_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_tci_transfer_case_information_actual_gear_ratio_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci_transfer_case_information_actual_gear_ratio_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci_transfer_case_information_actual_gear_ratio_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tci_transfer_case_information_message_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci_transfer_case_information_message_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci_transfer_case_information_message_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_tci_transfer_case_information_message_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_tci_transfer_case_information_message_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_tci_transfer_case_information_message_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRF1_Transmission_Fluids_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_trf1_transmission_fluids_1_pack(
    uint8_t *dst_p,
    const struct dura_max_trf1_transmission_fluids_1_t *src_p,
    size_t size);

/**
 * Unpack message TRF1_Transmission_Fluids_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_trf1_transmission_fluids_1_unpack(
    struct dura_max_trf1_transmission_fluids_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TRF1_Transmission_Fluids_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_trf1_transmission_fluids_1_init(struct dura_max_trf1_transmission_fluids_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_trf1_transmission_fluids_1_clutch_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_clutch_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_clutch_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_trf1_transmission_fluids_1_trans_oil_level1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_trans_oil_level1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_trans_oil_level1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_trf1_transmission_fluids_1_trans_filter_diff_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_trans_filter_diff_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_trans_filter_diff_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_trf1_transmission_fluids_1_trans_oil_press_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_trans_oil_press_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_trans_oil_press_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_trf1_transmission_fluids_1_trans_oil_temp1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_trans_oil_temp1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_trans_oil_temp1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_trf1_transmission_fluids_1_trans_oil_level1_high_low_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_trans_oil_level1_high_low_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_trans_oil_level1_high_low_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_trf1_transmission_fluids_1_trans_oil_level1_countdown_timer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_trans_oil_level1_countdown_timer_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_trans_oil_level1_countdown_timer_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_trf1_transmission_fluids_1_trans_oil_level1_measurement_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_trf1_transmission_fluids_1_trans_oil_level1_measurement_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_trf1_transmission_fluids_1_trans_oil_level1_measurement_status_is_in_range(uint8_t value);

/**
 * Pack message CCSS_Cruise_Control_Vehicle_Spd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_ccss_cruise_control_vehicle_spd_pack(
    uint8_t *dst_p,
    const struct dura_max_ccss_cruise_control_vehicle_spd_t *src_p,
    size_t size);

/**
 * Unpack message CCSS_Cruise_Control_Vehicle_Spd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_ccss_cruise_control_vehicle_spd_unpack(
    struct dura_max_ccss_cruise_control_vehicle_spd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CCSS_Cruise_Control_Vehicle_Spd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_ccss_cruise_control_vehicle_spd_init(struct dura_max_ccss_cruise_control_vehicle_spd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_max_vehicle_speed_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_max_vehicle_speed_limit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_max_vehicle_speed_limit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_cruise_ctrl_high_set_limit_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_cruise_ctrl_high_set_limit_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_cruise_ctrl_high_set_limit_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_cruise_ctrl_low_set_limit_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_cruise_ctrl_low_set_limit_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_cruise_ctrl_low_set_limit_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_ccss_cruise_control_vehicle_spd_max_vehicle_speed_limit6808_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_max_vehicle_speed_limit6808_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_max_vehicle_speed_limit6808_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_ctrl_sys_low_set_lmt_spd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_ctrl_sys_low_set_lmt_spd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_ctrl_sys_low_set_lmt_spd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_ctrl_dis_cmd_support_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_ctrl_dis_cmd_support_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_ctrl_dis_cmd_support_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_ctrl_resume_cmd_support_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_ctrl_resume_cmd_support_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_ctrl_resume_cmd_support_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_ctrl_pause_cmd_support_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_ctrl_pause_cmd_support_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_ctrl_pause_cmd_support_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_ctrl_set_cmd_support_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_ctrl_set_cmd_support_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_ctrl_set_cmd_support_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccss_cruise_control_vehicle_spd_powertrain_adaptive_cc_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccss_cruise_control_vehicle_spd_powertrain_adaptive_cc_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccss_cruise_control_vehicle_spd_powertrain_adaptive_cc_type_is_in_range(uint8_t value);

/**
 * Pack message CCVS1__Cruise_Control_VehSpd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_ccvs1_cruise_control_veh_spd_pack(
    uint8_t *dst_p,
    const struct dura_max_ccvs1_cruise_control_veh_spd_t *src_p,
    size_t size);

/**
 * Unpack message CCVS1__Cruise_Control_VehSpd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_ccvs1_cruise_control_veh_spd_unpack(
    struct dura_max_ccvs1_cruise_control_veh_spd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CCVS1__Cruise_Control_VehSpd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_ccvs1_cruise_control_veh_spd_init(struct dura_max_ccvs1_cruise_control_veh_spd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_two_speed_axle_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_two_speed_axle_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_two_speed_axle_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_parking_brake_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_parking_brake_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_parking_brake_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_pause_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_pause_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_pause_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_park_brake_release_inhibit_rq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_park_brake_release_inhibit_rq_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_park_brake_release_inhibit_rq_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t dura_max_ccvs1_cruise_control_veh_spd_wheel_based_vehicle_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_wheel_based_vehicle_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_wheel_based_vehicle_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_enable_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_enable_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_enable_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_brake_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_brake_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_brake_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_clutch_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_clutch_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_clutch_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_set_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_set_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_set_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_coast_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_coast_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_coast_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_resume_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_resume_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_resume_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_accelerate_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_accelerate_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_accelerate_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_set_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_set_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_set_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_pto_governor_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_pto_governor_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_pto_governor_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_states_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_states_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_cruise_ctrl_states_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_eng_idle_increment_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_eng_idle_increment_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_eng_idle_increment_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_eng_idle_decrement_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_eng_idle_decrement_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_eng_idle_decrement_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_eng_test_mode_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_eng_test_mode_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_eng_test_mode_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ccvs1_cruise_control_veh_spd_eng_shutdown_override_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ccvs1_cruise_control_veh_spd_eng_shutdown_override_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ccvs1_cruise_control_veh_spd_eng_shutdown_override_switch_is_in_range(uint8_t value);

/**
 * Pack message EBC1_Electronic_Brake_Cntrl.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_ebc1_electronic_brake_cntrl_pack(
    uint8_t *dst_p,
    const struct dura_max_ebc1_electronic_brake_cntrl_t *src_p,
    size_t size);

/**
 * Unpack message EBC1_Electronic_Brake_Cntrl.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_ebc1_electronic_brake_cntrl_unpack(
    struct dura_max_ebc1_electronic_brake_cntrl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EBC1_Electronic_Brake_Cntrl.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_ebc1_electronic_brake_cntrl_init(struct dura_max_ebc1_electronic_brake_cntrl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_asr_eng_ctrl_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_asr_eng_ctrl_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_asr_eng_ctrl_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_asr_brake_ctrl_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_asr_brake_ctrl_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_asr_brake_ctrl_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_anti_lock_braking_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_anti_lock_braking_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_anti_lock_braking_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_ebs_brake_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_ebs_brake_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_ebs_brake_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_brake_pedal_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_brake_pedal_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_brake_pedal_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_abs_offroad_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_abs_offroad_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_abs_offroad_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_asr_offroad_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_asr_offroad_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_asr_offroad_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_asr_hill_holder_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_asr_hill_holder_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_asr_hill_holder_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_traction_ctrl_override_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_traction_ctrl_override_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_traction_ctrl_override_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_accel_interlock_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_accel_interlock_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_accel_interlock_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_eng_derate_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_eng_derate_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_eng_derate_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_eng_aux_shutdown_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_eng_aux_shutdown_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_eng_aux_shutdown_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_remote_accel_enable_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_remote_accel_enable_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_remote_accel_enable_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_eng_retarder_selection_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_eng_retarder_selection_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_eng_retarder_selection_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_abs_fully_operational_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_abs_fully_operational_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_abs_fully_operational_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_ebs_red_warning_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_ebs_red_warning_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_ebs_red_warning_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_abs_ebs_amber_warning_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_abs_ebs_amber_warning_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_abs_ebs_amber_warning_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_atc_asr_information_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_atc_asr_information_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_atc_asr_information_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_src_addrss_of_cntrllng_dvc_fr_brke_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_src_addrss_of_cntrllng_dvc_fr_brke_ctrl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_src_addrss_of_cntrllng_dvc_fr_brke_ctrl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_railroad_mode_sw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_railroad_mode_sw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_railroad_mode_sw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_halt_brake_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_halt_brake_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_halt_brake_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_trailer_abs_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_trailer_abs_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_trailer_abs_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_ebc1_electronic_brake_cntrl_trctr_mntd_trailer_abs_warning_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_ebc1_electronic_brake_cntrl_trctr_mntd_trailer_abs_warning_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_ebc1_electronic_brake_cntrl_trctr_mntd_trailer_abs_warning_signal_is_in_range(uint8_t value);

/**
 * Pack message SHUTDN.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int dura_max_shutdn_pack(
    uint8_t *dst_p,
    const struct dura_max_shutdn_t *src_p,
    size_t size);

/**
 * Unpack message SHUTDN.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int dura_max_shutdn_unpack(
    struct dura_max_shutdn_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SHUTDN.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int dura_max_shutdn_init(struct dura_max_shutdn_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_idle_shutdown_has_shutdown_eng_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_idle_shutdown_has_shutdown_eng_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_idle_shutdown_has_shutdown_eng_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_idle_shutdown_driver_alert_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_idle_shutdown_driver_alert_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_idle_shutdown_driver_alert_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_idle_shutdown_timer_override_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_idle_shutdown_timer_override_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_idle_shutdown_timer_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_idle_shutdown_timer_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_idle_shutdown_timer_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_idle_shutdown_timer_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_idle_shutdown_timer_function_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_idle_shutdown_timer_function_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_idle_shutdown_timer_function_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_a_c_high_press_fan_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_a_c_high_press_fan_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_a_c_high_press_fan_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_refrigerant_low_press_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_refrigerant_low_press_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_refrigerant_low_press_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_refrigerant_high_press_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_refrigerant_high_press_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_refrigerant_high_press_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_wait_to_start_lamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_wait_to_start_lamp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_wait_to_start_lamp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_prtection_system_has_shutdown_eng_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_prtection_system_has_shutdown_eng_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_prtection_system_has_shutdown_eng_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_prtctn_systm_appraching_shutdown_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_prtctn_systm_appraching_shutdown_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_prtctn_systm_appraching_shutdown_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_protection_system_timer_override_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_protection_system_timer_override_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_protection_system_timer_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_protection_system_timer_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_protection_system_timer_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_protection_system_timer_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_protection_system_config_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_protection_system_config_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_protection_system_config_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_alarm_acknowledge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_alarm_acknowledge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_alarm_acknowledge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_alarm_output_cmd_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_alarm_output_cmd_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_alarm_output_cmd_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_air_shutoff_cmd_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_air_shutoff_cmd_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_air_shutoff_cmd_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_overspeed_test_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_overspeed_test_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_overspeed_test_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_air_shutoff_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_air_shutoff_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_air_shutoff_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_pto_shutdown_has_shutdown_eng_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_pto_shutdown_has_shutdown_eng_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_pto_shutdown_has_shutdown_eng_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_clnt_lvl_eng_prtction_shutdown_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_clnt_lvl_eng_prtction_shutdown_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_clnt_lvl_eng_prtction_shutdown_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t dura_max_shutdn_eng_oil_press_sw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double dura_max_shutdn_eng_oil_press_sw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool dura_max_shutdn_eng_oil_press_sw_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
